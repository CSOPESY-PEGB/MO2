#ifndef OSEMU_COMMANDS_H_
#define OSEMU_COMMANDS_H_

#include <string_view>
#include <unordered_map>

namespace osemu {

enum class Commands {
  Initialize,
  Screen,
  SchedulerStart,
  SchedulerStop,
  ReportUtil,
  Clear,
  Exit,
  ProcessSmi,
  Vmstat
};

Commands from_str(std::string_view cmd);

}

#endif
#ifndef OSEMU_CONFIG_H_
#define OSEMU_CONFIG_H_

#include <cstdint>
#include <filesystem>

namespace osemu {

enum class SchedulingAlgorithm { FCFS, RoundRobin };

struct Config {
  uint32_t cpuCount{4};
  SchedulingAlgorithm scheduler{SchedulingAlgorithm::RoundRobin};
  uint32_t quantumCycles{5};
  uint32_t processGenFrequency{1};
  uint32_t minInstructions{1000};
  uint32_t maxInstructions{2000};
  uint32_t delayCyclesPerInstruction{0};
  // old
  // uint32_t maxOverallMemory{1024};
  // uint32_t memPerFrame{64};
  // uint32_t minMemPerProc{512};
  // uint32_t maxMemPerProc{1024};

  // updated
  // default values
  uint32_t max_overall_mem{16384};
  uint32_t mem_per_frame{16};
  uint32_t min_mem_per_proc{4096};
  uint32_t max_mem_per_proc{4096};

  explicit Config(uint32_t cpu = 4,
                  SchedulingAlgorithm sched = SchedulingAlgorithm::RoundRobin,
                  uint32_t quantum = 5, uint32_t freq = 1,
                 uint32_t minIns = 1000, uint32_t maxIns = 2000,
                 uint32_t delay = 0, uint32_t mem_per_frame = 16,
                 uint32_t min_mem_per_proc = 4096, uint32_t max_mem_per_proc = 4096,
                 uint32_t max_overall_mem = 16384);

  static Config fromFile(const std::filesystem::path& file);
};

}

#endif
#ifndef OSEMU_CONSOLE_H_
#define OSEMU_CONSOLE_H_

namespace osemu {

void console_prompt();

}

#endif 
#ifndef OSEMU_DISPATCHER_H_
#define OSEMU_DISPATCHER_H_

#include <string>
#include <vector>

#include "commands.hpp"

namespace osemu {

class Config;
class Scheduler;

void dispatch(Commands cmd, std::vector<std::string>& args, Config& cfg,
              Scheduler& scheduler);

}  

#endif  
#ifndef OSEMU_INSTRUCTION_EVALUATOR_H_
#define OSEMU_INSTRUCTION_EVALUATOR_H_

#include <string>
#include <vector>
#include <memory>
#include <unordered_map>

#include "instruction_parser.hpp"

namespace osemu {

// Forward declarations to break circular dependencies
class MemoryManager;
class PCB;

class InstructionEvaluator {
private:
  // References to the PCB's state
  std::unordered_map<std::string, uint16_t>& symbol_table_;
  std::vector<std::string>& output_log_;
  std::string& process_name_;
  size_t& memory_size_ref_; // Reference to the PCB's total memory size

public:
  InstructionEvaluator(
      std::unordered_map<std::string, uint16_t>& symbol_table,
      std::vector<std::string>& output_log,
      std::string& process_name,
      size_t& memory_size
  );

  // Public helper for calculating stack addresses.
  uint16_t get_or_create_variable_address(const std::string& var_name);

  // Core evaluation logic for non-memory-access instructions
  void evaluate(const Expr& expr, MemoryManager& mm, uint32_t pcb_id);

  // Public functions to resolve values, which requires the memory manager
  uint16_t resolve_atom_value(const Atom& atom, MemoryManager& mm, uint32_t pcb_id);
  std::string print_atom_to_string(const Atom& atom, MemoryManager& mm, uint32_t pcb_id);

  // Public log access
  const std::vector<std::string>& get_output_log() const { return output_log_; }
};

} // namespace osemu

#endif
#ifndef OSEMU_INSTRUCTION_GENERATOR_H_
#define OSEMU_INSTRUCTION_GENERATOR_H_

#include <vector>
#include <random>
#include <cstdint> // For uint32_t
#include "instruction_parser.hpp"

namespace osemu {

class InstructionGenerator {
public:
  InstructionGenerator();

  // This is the main public function.
  std::vector<Expr> generateRandomProgram(
      uint32_t min_instructions,
      uint32_t max_instructions,
      const std::string& process_name,
      size_t memory_size);

private:
  // --- NEW HELPER FUNCTION DECLARATIONS ---
  std::string generateVariableName(int index);
  size_t generateHeapAddress(size_t heap_size);

  // Private member variables for random number generation
  std::mt19937 rng;
  std::uniform_int_distribution<uint16_t> value_dist;
  std::uniform_int_distribution<uint16_t> add_value_dist;
};

} // namespace osemu

#endif
#ifndef OSEMU_INSTRUCTION_PARSER_H_
#define OSEMU_INSTRUCTION_PARSER_H_

#include <string>
#include <vector>
#include <memory>
#include <variant>
#include <iostream>
#include <unordered_map>

namespace osemu {

struct Atom {
    enum Type { STRING, NAME, NUMBER };
    Type type;
    std::string string_value;
    uint16_t number_value;
    
    Atom(std::string s, Type t) : type(t), string_value(std::move(s)), number_value(0) {}
    Atom(uint16_t n) : type(NUMBER), number_value(n) {}
    
    std::string to_string() const {
        switch (type) {
            case STRING:
            case NAME:
                return string_value;
            case NUMBER:
                return std::to_string(number_value);
        }
        return "THIS SHOULDNT HAPPEN";
    }
};

struct Expr {
    enum Type { DECLARE, CALL, CONSTANT, VOID_EXPR, ADD, SUB, FOR, READ, WRITE };
    Type type;
    
    std::string var_name;
    std::unique_ptr<Atom> atom_value;
    std::unique_ptr<Atom> lhs;
    std::unique_ptr<Atom> rhs;
    std::unique_ptr<Atom> n;
    std::vector<Expr> body;
    
    Expr(Type t) : type(t) {}
    
    Expr(const Expr& other)
        : type(other.type), var_name(other.var_name) {
        if (other.atom_value) {
            atom_value = std::make_unique<Atom>(*other.atom_value);
        }
        if (other.lhs) {
            lhs = std::make_unique<Atom>(*other.lhs);
        }
        if (other.rhs) {
            rhs = std::make_unique<Atom>(*other.rhs);
        }
        if (other.n) {
            n = std::make_unique<Atom>(*other.n);
        }
        body = other.body;
    }
    
    Expr& operator=(const Expr& other) {
        if (this != &other) {
            type = other.type;
            var_name = other.var_name;
            atom_value.reset();
            if (other.atom_value) {
                atom_value = std::make_unique<Atom>(*other.atom_value);
            }
            
            lhs.reset();
            if (other.lhs) {
                lhs = std::make_unique<Atom>(*other.lhs);
            }
            
            rhs.reset();
            if (other.rhs) {
                rhs = std::make_unique<Atom>(*other.rhs);
            }
            
            n.reset();
            if (other.n) {
                n = std::make_unique<Atom>(*other.n);
            }
            
            body = other.body;
        }
        return *this;
    }
    
    Expr(Expr&& other) noexcept
        : type(other.type), var_name(std::move(other.var_name)),
          atom_value(std::move(other.atom_value)),
          lhs(std::move(other.lhs)), rhs(std::move(other.rhs)),
          n(std::move(other.n)), body(std::move(other.body)) {}
    
    Expr& operator=(Expr&& other) noexcept {
        if (this != &other) {
            type = other.type;
            var_name = std::move(other.var_name);
            atom_value = std::move(other.atom_value);
            lhs = std::move(other.lhs);
            rhs = std::move(other.rhs);
            n = std::move(other.n);
            body = std::move(other.body);
        }
        return *this;
    }
    
    static Expr make_declare(std::string name, std::unique_ptr<Atom> value) {
        Expr e(DECLARE);
        e.var_name = std::move(name);
        e.atom_value = std::move(value);
        return e;
    }
    
    static Expr make_call(std::string name, std::unique_ptr<Atom> arg) {
        Expr e(CALL);
        e.var_name = std::move(name);
        e.atom_value = std::move(arg);
        return e;
    }

    static Expr make_call_concat(std::string name, std::unique_ptr<Atom> lhs, std::unique_ptr<Atom> rhs) {
        Expr e(CALL);
        e.var_name = std::move(name);
        e.lhs = std::move(lhs);
        e.rhs = std::move(rhs);
        return e;
    }
    
    static Expr make_add(std::string var, std::unique_ptr<Atom> lhs, std::unique_ptr<Atom> rhs) {
        Expr e(ADD);
        e.var_name = std::move(var);
        e.lhs = std::move(lhs);
        e.rhs = std::move(rhs);
        return e;
    }
    
    static Expr make_sub(std::string var, std::unique_ptr<Atom> lhs, std::unique_ptr<Atom> rhs) {
        Expr e(SUB);
        e.var_name = std::move(var);
        e.lhs = std::move(lhs);
        e.rhs = std::move(rhs);
        return e;
    }
    
    static Expr make_for(std::vector<Expr> body, std::unique_ptr<Atom> n) {
        Expr e(FOR);
        e.body = std::move(body);
        e.n = std::move(n);
        return e;
    }
    
    static Expr make_constant(std::unique_ptr<Atom> value) {
        Expr e(CONSTANT);
        e.atom_value = std::move(value);
        return e;
    }

    // Static methods for READ and WRITE operations
    static Expr make_read(std::string var_name, std::unique_ptr<Atom> address) {
    Expr e(READ);
    e.var_name = std::move(var_name);   // destination variable
    e.atom_value = std::move(address);  // memory address to read from
    return e;
    }   

    static Expr make_write(std::unique_ptr<Atom> address, std::unique_ptr<Atom> value) {
        Expr e(WRITE);
        e.lhs = std::move(address);  // memory address
        e.rhs = std::move(value);    // value to write
        return e;
    }
    
};

struct ParseResult {
    bool success;
    std::string remaining;
    std::string error_msg;
    
    ParseResult(bool s, const std::string& r, const std::string& e = "") 
        : success(s), remaining(r), error_msg(e) {}
};

class InstructionParser {
public:
    static std::string ltrim(const std::string& input);
    static ParseResult parse_string(const std::string& input, Atom& result);
    static ParseResult parse_name(const std::string& input, Atom& result);
    static ParseResult parse_number(const std::string& input, Atom& result);
    static ParseResult parse_address(const std::string& input, Atom& result);
    static ParseResult parse_atom(const std::string& input, Atom& result);
    static ParseResult parse_declare(const std::string& input, Expr& result);
    static ParseResult parse_add(const std::string& input, Expr& result);
    static ParseResult parse_sub(const std::string& input, Expr& result);
    static ParseResult parse_call(const std::string& input, Expr& result);
    static ParseResult parse_for(const std::string& input, Expr& result);
    static ParseResult parse_expr(const std::string& input, Expr& result);
    static ParseResult parse_read(const std::string& input, Expr& result);
    static ParseResult parse_write(const std::string& input, Expr& result);
    static ParseResult parse_program(const std::string& input, std::vector<Expr>& result);
    
private:
    static bool consume_tag(const std::string& input, const std::string& tag, std::string& remaining);
};

}

#endif
#ifndef OSEMU_MEMORY_MANAGER_H_
#define OSEMU_MEMORY_MANAGER_H_

#include <atomic>
#include <cstdint>
#include <fstream>
#include <list>
#include <memory>
#include <mutex>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

// --- Custom Exception Classes (should be defined once, here is a good place) ---
class PageFaultException : public std::exception {
public:
    const char* what() const noexcept override {
        return "A recoverable page fault occurred.";
    }
};
class ResourceLimitException : public std::runtime_error {
public:
  ResourceLimitException(const std::string& msg) : std::runtime_error(msg) {}
};

class AccessViolationException : public std::runtime_error {
public:
    AccessViolationException(const std::string& msg) : std::runtime_error(msg) {}
};


namespace osemu {

// Forward declarations
class PCB;
class Config;

// Data structures for paging
struct PageTableEntry {
    bool is_valid = false;      // Is the page in a frame? (the "present" bit)
    bool is_dirty = false;      // Has the page been written to since being loaded?
    bool is_referenced = false; // Has the page been accessed recently? (for LRU)
    uint32_t frame_id = 0;      // Which physical frame holds this page?
};

struct Frame {
    uint32_t id;
    uint32_t pcb_id = 0;   // Which process owns the page in this frame?
    uint32_t page_id = 0;  // Which virtual page is in this frame?
    bool is_free = true;

    Frame(uint32_t id) : id(id) {} // Simple constructor
};

class MemoryManager {
public:
    explicit MemoryManager(const Config& config); // Takes Config for all memory params

    // Process lifecycle management
    void cleanup_process(uint32_t pcb_id);

    // The single, core function for memory access
    uint32_t translate_address(uint32_t pcb_id, uint32_t virtual_address);

    // Convenience wrappers around translate_address
    uint16_t read_u16(uint32_t pcb_id, uint32_t virtual_address);
    void write_u16(uint32_t pcb_id, uint32_t virtual_address, uint16_t value);

    // Reporting functions
    void generate_process_smi_report(std::ostream& out, const std::unordered_map<std::string, std::shared_ptr<PCB>>& all_processes) const;
    void generate_vmstat_report(std::ostream& out) const;
    bool register_process(std::shared_ptr<PCB> pcb);
    bool is_registered(uint32_t pcb_id) const; // New function
     uint32_t get_free_frame_count() const; // <-- Add this new public method

private:
    // Paging mechanism helpers
    void handle_page_fault(uint32_t pcb_id, uint32_t virtual_address);
    uint32_t find_victim_frame();
    uint32_t allocate_frame();
    void evict_page(uint32_t frame_id);

    // Backing store I/O
    void save_page_to_backing_store(uint32_t pcb_id, uint32_t page_id, uint32_t frame_id);
    bool load_page_from_backing_store(uint32_t pcb_id, uint32_t page_id, uint32_t frame_id);

    // Configuration
    uint32_t total_memory_size_;
    uint32_t frame_size_;
    uint32_t num_frames_;

    // Main data structures
    std::vector<uint8_t> physical_memory_; // Represents the "physical RAM"
    std::vector<Frame> frames_;            // Management data for each frame of RAM
    std::unordered_map<uint32_t, std::vector<PageTableEntry>> page_tables_; // pcb_id -> page table

    // Backing Store
    std::string backing_store_filename_;

    // Synchronization
    mutable std::mutex memory_mutex_;

    // Statistics for vmstat
    mutable std::atomic<size_t> pages_paged_in_{0};
    mutable std::atomic<size_t> pages_paged_out_{0};
};

} // namespace osemu

#endif
#ifndef OSEMU_PARSER_H_
#define OSEMU_PARSER_H_

#include <string>
#include <vector>

namespace osemu {

std::vector<std::string> ParseTokens(const std::string& line);

}  

#endif  
#ifndef OSEMU_PROCESS_CONTROL_BLOCK_H_
#define OSEMU_PROCESS_CONTROL_BLOCK_H_

#include <atomic>
#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <vector>
#include <unordered_map>

#include "instruction_evaluator.hpp" // Needs full definition to hold a unique_ptr

namespace osemu {

// Forward declare to avoid circular includes
class MemoryManager;

class PCB : public std::enable_shared_from_this<PCB> {
private:
    // --- NEW --- Member variables for state tracking
    bool terminated_ = false;
    std::string termination_reason_ = "";
    size_t memory_size_;

public:
    // --- UPDATED --- Constructor
    PCB(std::string procName, const std::vector<Expr>& instrs, size_t memory_size);

    static std::atomic<uint32_t> next_pid;

    // --- UPDATED --- Core execution functions
    void step(MemoryManager& mm);
    bool executeCurrentInstruction(MemoryManager& mm);

    // --- NEW --- Methods for state management
    bool isTerminated() const { return terminated_; }
    size_t getMemorySize() const { return memory_size_; }
    void terminate(const std::string& reason);
    const std::string& getTerminationReason() const { return termination_reason_; }

    // --- EXISTING --- Public methods (no changes needed)
    bool isComplete() const;
    std::string status() const;
    const std::vector<std::string>& getExecutionLogs() const;
    void setSleepCycles(uint16_t cycles);
    bool isSleeping() const;
    void decrementSleepCycles();

    // --- EXISTING --- Public member variables
    uint32_t processID;
    std::string processName;
    size_t currentInstruction;
    size_t totalInstructions;
    std::chrono::system_clock::time_point creationTime;
    std::optional<int> assignedCore;
    std::chrono::system_clock::time_point finishTime;

    std::vector<Expr> instructions;
    uint16_t sleepCyclesRemaining;

    // --- EXISTING --- Members passed to the evaluator
    // Note: heap_memory is now obsolete but kept to avoid breaking the old evaluator constructor.
    // The new system uses the MemoryManager instead.
    std::vector<uint8_t> heap_memory;
    std::unordered_map<std::string, uint16_t> symbol_table;
    std::vector<std::string> output_log;
    std::unique_ptr<InstructionEvaluator> evaluator;
};

} // namespace osemu

#endif
#ifndef OSEMU_SCHEDULER_H_
#define OSEMU_SCHEDULER_H_

#include <atomic>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>
#include <unordered_map>

#include "process_control_block.hpp"
#include "thread_safe_queue.hpp"
#include "instruction_generator.hpp"
#include "config.hpp"
#include "memory_manager.hpp"
#include "cpu_worker.h"

namespace osemu {

class Config;

class Scheduler {
 public:
  Scheduler();
  ~Scheduler();

  void dispatch();
  void global_clock();
  void start(const Config& config);
  void stop();

  void submit_process(std::shared_ptr<PCB> pcb);
  void print_status() const; // This is the main user-facing status command

  void start_batch_generation();
  void stop_batch_generation();

  void move_to_running(std::shared_ptr<PCB> pcb);
  void move_to_finished(std::shared_ptr<PCB> pcb);
  void move_to_ready(std::shared_ptr<PCB> pcb);

  std::shared_ptr<PCB> find_process_by_name(const std::string& name) const;

  // Getters for child classes and external components
  size_t get_ticks() const { return ticks_.load(); }
  MemoryManager* get_memory_manager() { return memory_manager_.get(); }
  std::mutex& GetClockMutex() { return clock_mutex_; }
  std::condition_variable& GetClockCondition() { return clock_cv_; }
  bool IsRunning() const { return running_.load(); }
  size_t GetDelayPerExecution() const { return config_.delayCyclesPerInstruction; }
  const std::unordered_map<std::string, std::shared_ptr<PCB>>& get_all_processes_map() const {
    return all_processes_map_;
  }
  std::atomic<bool> batch_generating_;
  bool is_generating() const { return batch_generating_.load(); }
  void generate_full_report(const std::string& filename = "csopesy-log.txt") const;

 private:
  friend class CpuWorker;

  // Helper for reporting
  void calculate_cpu_utilization(size_t& total_cores, size_t& cores_used,
                                 double& cpu_utilization) const;

  // Core components
  Config config_;
  std::unique_ptr<MemoryManager> memory_manager_;
  std::vector<std::unique_ptr<CpuWorker>> cpu_workers_;

  // State
  std::atomic<bool> running_;
  ThreadSafeQueue<std::shared_ptr<PCB>> ready_queue_;

  // Process tracking lists and their mutexes
  mutable std::mutex running_mutex_;
  std::vector<std::shared_ptr<PCB>> running_processes_;
  mutable std::mutex finished_mutex_;
  std::vector<std::shared_ptr<PCB>> finished_processes_;
  mutable std::mutex map_mutex_;
  std::unordered_map<std::string, std::shared_ptr<PCB>> all_processes_map_;

  // Threads
  std::thread dispatch_thread_;
  std::thread global_clock_thread_;

  // Batch generation
  std::unique_ptr<std::thread> batch_generator_thread_;
  InstructionGenerator instruction_generator_;
  int process_counter_;
  mutable std::mutex process_counter_mutex_;

  // Clock
  std::atomic<size_t> ticks_{0};
  mutable std::mutex clock_mutex_;
  std::condition_variable clock_cv_;
};

} // namespace osemu

#endif
#ifndef OSEMU_SCREEN_H_
#define OSEMU_SCREEN_H_

#include <string>
#include <vector>

#include "config.hpp"

namespace osemu {

class Scheduler;

void screen(std::vector<std::string>& args, Scheduler& scheduler, Config& config);

}  

#endif  
#ifndef OSEMU_THREAD_SAFE_QUEUE_H_
#define OSEMU_THREAD_SAFE_QUEUE_H_

#include <condition_variable>
#include <memory>
#include <mutex>
#include <queue>
#include <iostream>

template <typename T>
class ThreadSafeQueue {

  public:
  void push(T value) {
    std::lock_guard<std::mutex> lock(mutex_);
        queue_.push_back(std::move(value)); // <-- Use push_back
    cond_.notify_one();
  }
  // --- ADD THIS NEW FUNCTION ---
  void push_front(T value) {
    std::lock_guard<std::mutex> lock(mutex_);
    queue_.push_front(std::move(value)); // <-- Use push_front
    cond_.notify_one();
  }
  void shutdown(){
    shutdown_requested_ = true;
    cond_.notify_all();
  }

  bool wait_and_pop(T& value) {
    std::unique_lock<std::mutex> lock(mutex_);
    cond_.wait(lock, [this] { return !queue_.empty() || shutdown_requested_.load(); });
    
    if (shutdown_requested_.load() && queue_.empty()) {
      return false;
    }

    
    value = std::move(queue_.front());
        queue_.pop_front(); // <-- Use pop_front
    return true;
  }

  void empty() {
    std::lock_guard lock(mutex_);
    while(!queue_.empty()){
      queue_.pop_front();
      std::cout << "emptied queue" << std::endl;
    }
  }

 private:
  mutable std::mutex mutex_;
  std::deque<T> queue_; // <-- USE DEQUE
  std::condition_variable cond_;
  std::atomic_bool shutdown_requested_;
};

#endif  
