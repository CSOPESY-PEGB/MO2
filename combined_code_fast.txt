
// =====================================================================
// FILE: ./build/CMakeFiles/4.0.3/CompilerIdCXX/CMakeCXXCompilerId.cpp
// =====================================================================

/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
# define COMPILER_VERSION_INTERNAL_STR  __clang_version__


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "ARM"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__) || defined(__CPARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define CXX_STD_98 199711L
#define CXX_STD_11 201103L
#define CXX_STD_14 201402L
#define CXX_STD_17 201703L
#define CXX_STD_20 202002L
#define CXX_STD_23 202302L

#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > CXX_STD_17
#    define CXX_STD _MSVC_LANG
#  elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14
#    define CXX_STD CXX_STD_17
#  elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  elif defined(__INTEL_CXX11_MODE__)
#    define CXX_STD CXX_STD_11
#  else
#    define CXX_STD CXX_STD_98
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > __cplusplus
#    define CXX_STD _MSVC_LANG
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__NVCOMPILER)
#  if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__INTEL_COMPILER) || defined(__PGI)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
#    define CXX_STD CXX_STD_17
#  elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif (defined(__IBMCPP__) || defined(__ibmxl__)) && defined(__linux__)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif __cplusplus == 1 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#  define CXX_STD CXX_STD_11
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > CXX_STD_23
  "26"
#elif CXX_STD > CXX_STD_20
  "23"
#elif CXX_STD > CXX_STD_17
  "20"
#elif CXX_STD > CXX_STD_14
  "17"
#elif CXX_STD > CXX_STD_11
  "14"
#elif CXX_STD >= CXX_STD_11
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#if defined(COMPILER_VERSION_INTERNAL) || defined(COMPILER_VERSION_INTERNAL_STR)
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}


// =====================================================================
// FILE: ./build/CMakeFiles/4.0.3/CompilerIdCXX/apple-sdk.cpp
// =====================================================================

#include <AvailabilityMacros.h>


// =====================================================================
// FILE: ./include/commands.hpp
// =====================================================================

#ifndef OSEMU_COMMANDS_H_
#define OSEMU_COMMANDS_H_

#include <string_view>
#include <unordered_map>

namespace osemu {

enum class Commands {
  Initialize,
  Screen,
  SchedulerStart,
  SchedulerStop,
  ReportUtil,
  ProcessSmi,
  Vmstat,
  Clear,
  Exit
};

Commands from_str(std::string_view cmd);

}

#endif


// =====================================================================
// FILE: ./include/config.hpp
// =====================================================================

#ifndef OSEMU_CONFIG_H_
#define OSEMU_CONFIG_H_

#include <cstdint>
#include <filesystem>

namespace osemu {

enum class SchedulingAlgorithm { FCFS, RoundRobin };

struct Config {
  uint32_t cpuCount{4};
  SchedulingAlgorithm scheduler{SchedulingAlgorithm::RoundRobin};
  uint32_t quantumCycles{5};
  uint32_t processGenFrequency{1};
  uint32_t minInstructions{1000};
  uint32_t maxInstructions{2000};
  uint32_t delayCyclesPerInstruction{0};
  uint32_t maxOverallMemory{1024};
  uint32_t memPerFrame{64};
 

  uint32_t max_overall_mem{16384};
  uint32_t mem_per_frame{16};
  uint32_t min_mem_per_proc{4096};
  uint32_t max_mem_per_proc{4096};

  explicit Config(uint32_t cpu = 4,
                  SchedulingAlgorithm sched = SchedulingAlgorithm::RoundRobin,
                  uint32_t quantum = 5, uint32_t freq = 1,
                  uint32_t minIns = 1000, uint32_t maxIns = 2000,
                  uint32_t delay = 0, uint32_t memPerFrame = 64, uint32_t minMemPerProc = 512, uint32_t maxMemPerProc = 1024, uint32_t maxOverallMemory = 1024);

  static Config fromFile(const std::filesystem::path& file);
};

}

#endif


// =====================================================================
// FILE: ./include/console.hpp
// =====================================================================

#ifndef OSEMU_CONSOLE_H_
#define OSEMU_CONSOLE_H_

namespace osemu {

void console_prompt();

}

#endif 


// =====================================================================
// FILE: ./include/cpu_worker.h
// =====================================================================

#ifndef OSEMU_CPU_WORKER_H_
#define OSEMU_CPU_WORKER_H_

#include <atomic>
#include <condition_variable>
#include <memory>
#include <mutex>
#include <thread>

#include "process_control_block.hpp"

namespace osemu {

// Forward declaration
class Scheduler;

// CpuWorker handles execution of processes on individual CPU cores.
// Each CpuWorker runs in its own thread and can execute one process at a time.
class CpuWorker {
 public:
  // Constructs a CpuWorker for the specified core ID and scheduler.
  // Args:
  //   core_id: The ID of the CPU core this worker represents
  //   scheduler: Reference to the scheduler that manages this worker
  CpuWorker(int core_id, Scheduler& scheduler);
  
  // Destructor ensures proper cleanup of resources
  ~CpuWorker() = default;
  
  // Non-copyable and non-movable
  CpuWorker(const CpuWorker&) = delete;
  CpuWorker& operator=(const CpuWorker&) = delete;
  CpuWorker(CpuWorker&&) = delete;
  CpuWorker& operator=(CpuWorker&&) = delete;

  // Starts the worker thread for this CPU core
  void Start();
  
  // Stops the worker thread and signals shutdown
  void Stop();
  
  // Waits for the worker thread to complete
  void Join();
  
  // Assigns a task to this worker with the specified time quantum
  // Args:
  //   pcb: Process to execute
  //   time_quantum: Maximum time slices to run (-1 for unlimited)
  void AssignTask(std::shared_ptr<PCB> pcb, int time_quantum);
  
  // Returns true if this worker is currently idle
  bool IsIdle() const { return is_idle_.load(); }
  
  // Returns the core ID this worker represents
  int GetCoreId() const { return core_id_; }

 private:
  // Main execution loop for the worker thread
  void Run();
  
  // Executes a single process for the specified time quantum
  // Args:
  //   pcb: Process to execute
  //   time_quantum: Maximum time slices to run
  void ExecuteProcess(std::shared_ptr<PCB> pcb, int time_quantum);

  const int core_id_;
  Scheduler& scheduler_;
  std::thread thread_;
  
  std::atomic<bool> is_idle_{true};
  std::atomic<bool> shutdown_requested_{false};
  
  std::shared_ptr<PCB> current_task_;
  int time_quantum_;
  int ticks_with_current_task_;
  
  mutable std::mutex mutex_;
  std::condition_variable condition_variable_;
};

}  // namespace osemu

#endif  // OSEMU_CPU_WORKER_H_

// =====================================================================
// FILE: ./include/dispatcher.hpp
// =====================================================================

#ifndef OSEMU_DISPATCHER_H_
#define OSEMU_DISPATCHER_H_

#include <string>
#include <vector>

#include "commands.hpp"

namespace osemu {

class Config;
class Scheduler;

void dispatch(Commands cmd, std::vector<std::string>& args, Config& cfg,
              Scheduler& scheduler);

}  

#endif  


// =====================================================================
// FILE: ./include/instruction_evaluator.hpp
// =====================================================================

#ifndef OSEMU_INSTRUCTION_EVALUATOR_H_
#define OSEMU_INSTRUCTION_EVALUATOR_H_

#include <string>
#include <vector>
#include <memory>
#include <variant>
#include <iostream>
#include <unordered_map>
#include "instruction_parser.hpp"

namespace osemu {

    class PCB;
    class MemoryManager;

    class InstructionEvaluator {
    private:
        //for now, we won't page this into separate blocks first but we will soon.
        std::vector<uint8_t>& heap_memory; 
        //here we store string(variable name):address(logical memory address, starts from the top of heap_memory) 
        std::unordered_map<std::string, uint16_t>& symbol_table; 
        //output log
        std::vector<std::string>& output_log;
        std::string& process_name;
        uint32_t pcb_id_;
        MemoryManager* memory_manager_;

        //helper functions for dealing with memory
        uint16_t get_or_create_variable_address(const std::string& var_name);
        uint16_t read_u16_from_heap(uint16_t address);
        void write_u16_to_heap(uint16_t address, uint16_t value);
        void write_u16_to_mem(uint16_t address, uint16_t value);
        
        // New memory management helpers
        uint16_t parse_hex_address(const std::string& hex_str);
        bool handle_memory_access_with_paging(uint32_t virtual_address);
        bool read_u16_with_paging(uint32_t virtual_address, uint16_t& value);
        bool write_u16_with_paging(uint32_t virtual_address, uint16_t value);

    public:
        InstructionEvaluator(std::vector<uint8_t>& heap_memory, 
            std::unordered_map<std::string, uint16_t>& symbol_table, 
            std::vector<std::string>& output_log, 
            std::string& process_name,
            uint32_t pcb_id,
            MemoryManager* memory_manager = nullptr);

        uint16_t resolve_atom_value(const Atom& atom);
        std::string print_atom_to_string(const Atom& atom);

        void evaluate(const Expr& expr);
        void evaluate_program(const std::vector<Expr>& program);

        void handle_declare(const std::string& var_name, const Atom& value);
        std::string handle_print(const Atom& arg, const std::string& process_name);
        void handle_sleep(const Atom& duration);
        void handle_add(const std::string& var, const Atom& lhs, const Atom& rhs);
        void handle_sub(const std::string& var, const Atom& lhs, const Atom& rhs);
        void handle_for(const std::vector<Expr>& body, const Atom& count);
        void handle_read(const std::string& var_name, const Atom& rhs);
        void handle_write(const Atom& address, const Atom& rhs);

        void clear_variables();
        void dump_variables() const;
        const std::vector<std::string>& get_output_log() const { return output_log; }
        void clear_output_log() { output_log.clear(); }
    };
}


#endif


// =====================================================================
// FILE: ./include/instruction_generator.hpp
// =====================================================================

#ifndef OSEMU_INSTRUCTION_GENERATOR_H_
#define OSEMU_INSTRUCTION_GENERATOR_H_

#include <vector>
#include <random>
#include "instruction_parser.hpp"

namespace osemu {

class InstructionGenerator {
private:
    std::mt19937 rng;
    std::uniform_int_distribution<int> instruction_type_dist;
    std::uniform_int_distribution<uint16_t> value_dist;
    std::uniform_int_distribution<int> var_name_dist;
    std::uniform_int_distribution<int> for_count_dist;
    std::uniform_int_distribution<int> for_body_size_dist;
    std::uniform_int_distribution<uint16_t> add_value_dist;

    std::string generateVariableName();
    size_t generateAddress(size_t memory_size);
    size_t generate_power_of_two(size_t, size_t);
    Expr generatePrintInstruction(const std::string& process_name);
    Expr generateDeclareInstruction();
    Expr generateAddInstruction();
    Expr generateSubtractInstruction();
    Expr generateSleepInstruction();
    Expr generateForInstruction(int max_depth = 3);


   public:
    InstructionGenerator();
    
    std::vector<Expr> generateInstructions(size_t count,
                                           const std::string& process_name,
                                           size_t memory_size);
                                           
    std::vector<Expr> generateRandomProgram(size_t min_instructions,
                                            size_t max_instructions,
                                            const std::string& process_name,
                                            size_t min_mem,
                                            size_t max_mem);
};

}  

#endif  


// =====================================================================
// FILE: ./include/instruction_parser.hpp
// =====================================================================

#ifndef OSEMU_INSTRUCTION_PARSER_H_
#define OSEMU_INSTRUCTION_PARSER_H_

#include <string>
#include <vector>
#include <memory>
#include <variant>
#include <iostream>
#include <unordered_map>

namespace osemu {

struct Atom {
    enum Type { STRING, NAME, NUMBER };
    Type type;
    std::string string_value;
    uint16_t number_value;
    
    Atom(std::string s, Type t) : type(t), string_value(std::move(s)), number_value(0) {}
    Atom(uint16_t n) : type(NUMBER), number_value(n) {}
    
    std::string to_string() const {
        switch (type) {
            case STRING:
            case NAME:
                return string_value;
            case NUMBER:
                return std::to_string(number_value);
        }
        return "THIS SHOULDNT HAPPEN";
    }
};

struct Expr {
    enum Type { DECLARE, CALL, CONSTANT, VOID_EXPR, ADD, SUB, FOR, READ, WRITE };
    Type type;
    
    std::string var_name;
    std::unique_ptr<Atom> atom_value;
    std::unique_ptr<Atom> lhs;
    std::unique_ptr<Atom> rhs;
    std::unique_ptr<Atom> n;
    std::vector<Expr> body;
    
    Expr(Type t) : type(t) {}
    
    Expr(const Expr& other)
        : type(other.type), var_name(other.var_name) {
        if (other.atom_value) {
            atom_value = std::make_unique<Atom>(*other.atom_value);
        }
        if (other.lhs) {
            lhs = std::make_unique<Atom>(*other.lhs);
        }
        if (other.rhs) {
            rhs = std::make_unique<Atom>(*other.rhs);
        }
        if (other.n) {
            n = std::make_unique<Atom>(*other.n);
        }
        body = other.body;
    }
    
    Expr& operator=(const Expr& other) {
        if (this != &other) {
            type = other.type;
            var_name = other.var_name;
            atom_value.reset();
            if (other.atom_value) {
                atom_value = std::make_unique<Atom>(*other.atom_value);
            }
            
            lhs.reset();
            if (other.lhs) {
                lhs = std::make_unique<Atom>(*other.lhs);
            }
            
            rhs.reset();
            if (other.rhs) {
                rhs = std::make_unique<Atom>(*other.rhs);
            }
            
            n.reset();
            if (other.n) {
                n = std::make_unique<Atom>(*other.n);
            }
            
            body = other.body;
        }
        return *this;
    }
    
    Expr(Expr&& other) noexcept
        : type(other.type), var_name(std::move(other.var_name)),
          atom_value(std::move(other.atom_value)),
          lhs(std::move(other.lhs)), rhs(std::move(other.rhs)),
          n(std::move(other.n)), body(std::move(other.body)) {}
    
    Expr& operator=(Expr&& other) noexcept {
        if (this != &other) {
            type = other.type;
            var_name = std::move(other.var_name);
            atom_value = std::move(other.atom_value);
            lhs = std::move(other.lhs);
            rhs = std::move(other.rhs);
            n = std::move(other.n);
            body = std::move(other.body);
        }
        return *this;
    }
    
    static Expr make_declare(std::string name, std::unique_ptr<Atom> value) {
        Expr e(DECLARE);
        e.var_name = std::move(name);
        e.atom_value = std::move(value);
        return e;
    }
    
    static Expr make_call(std::string name, std::unique_ptr<Atom> arg) {
        Expr e(CALL);
        e.var_name = std::move(name);
        e.atom_value = std::move(arg);
        return e;
    }

    static Expr make_call_concat(std::string name, std::unique_ptr<Atom> lhs, std::unique_ptr<Atom> rhs) {
        Expr e(CALL);
        e.var_name = std::move(name);
        e.lhs = std::move(lhs);
        e.rhs = std::move(rhs);
        return e;
    }
    
    static Expr make_add(std::string var, std::unique_ptr<Atom> lhs, std::unique_ptr<Atom> rhs) {
        Expr e(ADD);
        e.var_name = std::move(var);
        e.lhs = std::move(lhs);
        e.rhs = std::move(rhs);
        return e;
    }
    
    static Expr make_sub(std::string var, std::unique_ptr<Atom> lhs, std::unique_ptr<Atom> rhs) {
        Expr e(SUB);
        e.var_name = std::move(var);
        e.lhs = std::move(lhs);
        e.rhs = std::move(rhs);
        return e;
    }
    
    static Expr make_for(std::vector<Expr> body, std::unique_ptr<Atom> n) {
        Expr e(FOR);
        e.body = std::move(body);
        e.n = std::move(n);
        return e;
    }
    
    static Expr make_constant(std::unique_ptr<Atom> value) {
        Expr e(CONSTANT);
        e.atom_value = std::move(value);
        return e;
    }

    // Static methods for READ and WRITE operations
    static Expr make_read(std::string var_name, std::unique_ptr<Atom> address) {
    Expr e(READ);
    e.var_name = std::move(var_name);   // destination variable
    e.atom_value = std::move(address);  // memory address to read from
    return e;
    }   

    static Expr make_write(std::unique_ptr<Atom> address, std::unique_ptr<Atom> value) {
        Expr e(WRITE);
        e.lhs = std::move(address);  // memory address
        e.rhs = std::move(value);    // value to write
        return e;
    }
    
};

struct ParseResult {
    bool success;
    std::string remaining;
    std::string error_msg;
    
    ParseResult(bool s, const std::string& r, const std::string& e = "") 
        : success(s), remaining(r), error_msg(e) {}
};

class InstructionParser {
public:
    static std::string ltrim(const std::string& input);
    static ParseResult parse_string(const std::string& input, Atom& result);
    static ParseResult parse_name(const std::string& input, Atom& result);
    static ParseResult parse_number(const std::string& input, Atom& result);
    static ParseResult parse_address(const std::string& input, Atom& result);
    static ParseResult parse_atom(const std::string& input, Atom& result);
    static ParseResult parse_declare(const std::string& input, Expr& result);
    static ParseResult parse_add(const std::string& input, Expr& result);
    static ParseResult parse_sub(const std::string& input, Expr& result);
    static ParseResult parse_call(const std::string& input, Expr& result);
    static ParseResult parse_for(const std::string& input, Expr& result);
    static ParseResult parse_expr(const std::string& input, Expr& result);
    static ParseResult parse_read(const std::string& input, Expr& result);
    static ParseResult parse_write(const std::string& input, Expr& result);
    static ParseResult parse_program(const std::string& input, std::vector<Expr>& result);
    
private:
    static bool consume_tag(const std::string& input, const std::string& tag, std::string& remaining);
};

}

#endif


// =====================================================================
// FILE: ./include/memory_manager.hpp
// =====================================================================

#ifndef OSEMU_MEMORY_MANAGER_H_
#define OSEMU_MEMORY_MANAGER_H_

#include <cstdint>
#include <list>
#include <memory>
#include <mutex>
#include <string>
#include <vector>
#include <unordered_map>
#include <fstream>

#include "process_control_block.hpp"

namespace osemu {

struct MemoryBlock {
    uint32_t start_address;
    uint32_t size;
    bool is_free;
    uint32_t pcb_id;
    std::shared_ptr<PCB> pcb_block;
};

struct Frame {
    uint32_t frame_id;
    bool is_free;
    uint32_t pcb_id;
    uint32_t page_id;
    std::vector<uint8_t> data;
    
    Frame(uint32_t id, uint32_t frame_size) : frame_id(id), is_free(true), pcb_id(0), page_id(0), data(frame_size, 0) {}
};

struct PageTableEntry {
    bool is_valid;
    uint32_t frame_id; 
    bool is_dirty;
    bool is_referenced;
    
    PageTableEntry() : is_valid(false), frame_id(0), is_dirty(false), is_referenced(false) {}
};

class MemoryManager {
public:
    explicit MemoryManager(uint32_t total_size, uint32_t frame_size = 16);
    bool allocate(uint32_t pcb_id, uint32_t size, std::shared_ptr<PCB> pcb_block);
    void free(uint32_t pcb_id);

    // NEW: Method to check if a process is already in memory.
    // This is a const method because it only reads the memory state.
    bool is_allocated(uint32_t pcb_id) const;
    void generate_memory_report(const std::string& filename) const;
    void generate_memory_report(std::ostream& out) const;
    void write_memory_report(std::ostream& out) const; // Internal reusable helper
    
    // Demand paging methods
    bool handle_page_fault(uint32_t pcb_id, uint32_t virtual_address);
    bool read_from_memory(uint32_t pcb_id, uint32_t virtual_address, uint16_t& value);
    bool write_to_memory(uint32_t pcb_id, uint32_t virtual_address, uint16_t value);
    void initialize_page_table(uint32_t pcb_id, uint32_t num_pages);
    
    // Statistics for vmstat
    size_t get_pages_paged_in() const { return pages_paged_in_; }
    size_t get_pages_paged_out() const { return pages_paged_out_; }
    uint32_t get_total_memory() const { return total_memory_size_; }
    uint32_t get_used_memory() const;
    uint32_t get_free_memory() const;
    
private:
    void save_page_to_backing_store(uint32_t pcb_id, uint32_t page_id, const std::vector<uint8_t>& data);
    bool load_page_from_backing_store(uint32_t pcb_id, uint32_t page_id, std::vector<uint8_t>& data);
    uint32_t find_victim_frame(); // LRU page replacement
    uint32_t allocate_frame();
    void evict_page(uint32_t frame_id);

private:
    void coalesce_free_blocks(std::list<MemoryBlock>::iterator newly_freed_block);
    std::list<MemoryBlock> memory_map_;
    uint32_t total_memory_size_;
    mutable std::mutex memory_mutex_;
    
    // Demand paging structures
    std::vector<Frame> frames_;
    std::unordered_map<uint32_t, std::vector<PageTableEntry>> page_tables_; // pcb_id -> page table
    uint32_t frame_size_;
    uint32_t num_frames_;
    std::string backing_store_filename_;
    
    // Statistics
    mutable std::atomic<size_t> pages_paged_in_{0};
    mutable std::atomic<size_t> pages_paged_out_{0};
};

}
#endif


// =====================================================================
// FILE: ./include/parser.hpp
// =====================================================================

#ifndef OSEMU_PARSER_H_
#define OSEMU_PARSER_H_

#include <string>
#include <vector>

namespace osemu {

std::vector<std::string> ParseTokens(const std::string& line);

}  

#endif  


// =====================================================================
// FILE: ./include/process_control_block.hpp
// =====================================================================

#ifndef OSEMU_PROCESS_CONTROL_BLOCK_H_
#define OSEMU_PROCESS_CONTROL_BLOCK_H_

#include "instruction_evaluator.hpp"


#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <vector>
#include <atomic>
#include <map>

namespace osemu {

class InstructionEvaluator;
class MemoryManager;

enum class InstructionResult {
    SUCCESS,        // Instruction executed successfully
    PAGE_FAULT,     // Instruction caused a page fault (needed page not in memory)
    PROCESS_COMPLETE // Instruction caused the process to complete (e.g., last instruction)
};

struct InstructionExecutionInfo{
  InstructionResult result;
  size_t faulting_virtual_address;

  // Default constructor: Initializes to SUCCESS, with no faulting address
  InstructionExecutionInfo() : result(InstructionResult::SUCCESS), faulting_virtual_address(0) {}
  // Parameterized constructor: For specifying result and an optional faulting address
  InstructionExecutionInfo(InstructionResult r, size_t addr = 0)
      : result(r), faulting_virtual_address(addr) {}
};

class PCB : public std::enable_shared_from_this<PCB> {
 public:
  PCB(std::string procName, size_t totalLines, MemoryManager* memory_manager = nullptr);
  PCB(std::string procName, const std::vector<Expr>& instructions, MemoryManager* memory_manager = nullptr);
  PCB(std::string procName, const std::vector<Expr>& instrs,
      size_t memory_size, MemoryManager* memory_manager = nullptr);
  static std::atomic<uint32_t> next_pid;

  InstructionExecutionInfo step();
  bool isComplete() const;
  std::string status() const;
  
  
  bool executeCurrentInstruction();
  const std::vector<std::string>& getExecutionLogs() const;
  
  
  void setSleepCycles(uint16_t cycles);
  bool isSleeping() const;
  void decrementSleepCycles();

  uint32_t processID;
  std::string processName;
  size_t currentInstruction;
  size_t totalInstructions;
  std::chrono::system_clock::time_point creationTime;

  
  std::optional<int> assignedCore;
  std::chrono::system_clock::time_point finishTime;
  
  size_t symbol_table_limit = 32; // Limit for symbol table size
  size_t symbol_table_size = 0; // Current size of the symbol table

  
  std::vector<Expr> instructions;
  uint16_t sleepCyclesRemaining;

  //evaluator stuff
  std::vector<uint8_t> heap_memory; //for now, this is the raw memory representation, this will be replaced with a page table.
  std::unordered_map<std::string, uint16_t> symbol_table; //here we store string(variable name):address(logical memory address, starts from the top of heap_memory) 
  std::vector<std::string> output_log;
  std::unique_ptr<InstructionEvaluator> evaluator; //evaluator takes all the top 3 members as its members too.

};

}  

#endif  


// =====================================================================
// FILE: ./include/scheduler.hpp
// =====================================================================

#ifndef OSEMU_SCHEDULER_H_
#define OSEMU_SCHEDULER_H_

#include <atomic>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>
#include <unordered_map>
#include "process_control_block.hpp"
#include "thread_safe_queue.hpp"
#include "instruction_generator.hpp"
#include "config.hpp"
#include "memory_manager.hpp"
#include "cpu_worker.h"

namespace osemu {

class Config;

class Scheduler {
 public:
  Scheduler();
  ~Scheduler();

  void dispatch();
  void global_clock();
  void check_config_scheduler_for_discrepancies(const Config& config);

  void start(const Config& config);
  void stop();

  void submit_process(std::shared_ptr<PCB> pcb);
  void print_status() const;

  void start_batch_generation();
  void stop_batch_generation();
  void calculate_cpu_utilization(size_t& total_cores, size_t& cores_used,
                                 double& cpu_utilization) const;
  bool is_generating() const { return batch_generating_; }
  std::shared_ptr<PCB> find_process_by_name(const std::string& name) const;
  
  void move_to_running(std::shared_ptr<PCB> pcb);
  void move_to_finished(std::shared_ptr<PCB> pcb);
  void move_to_ready(std::shared_ptr<PCB> pcb);
  
  void generate_report(const std::string& filename = "csopesy-log.txt") const;
  void print_process_smi() const;
  void print_vmstat() const;

  size_t get_ticks() const { return ticks_.load(); }
  MemoryManager* get_memory_manager() const { return memory_manager_.get(); }
  
  // Public interface methods for CpuWorker access  
  std::mutex& GetClockMutex() { return clock_mutex_; }
  std::condition_variable& GetClockCondition() { return clock_cv_; }
  bool IsRunning() const { return running_.load(); }
  size_t GetDelayPerExecution() const { return delay_per_exec_; }

  std::unique_ptr<MemoryManager> memory_manager_;

  // --- Barrier Synchronization for CPU Workers ---
  std::atomic<int> workers_completed_step_count_{0}; // Count of workers done with current tick
  std::condition_variable dispatch_go_cv_; // Scheduler notifies workers to start their tick
  std::condition_variable workers_done_cv_; // Workers notify Scheduler they've finished their tick
  std::mutex barrier_mutex_; // Mutex protecting barrier counts and CVs
  
 private:
  friend class CpuWorker;
  
  bool find_idle_cpu();
  void signal_execute();
  void find_free_cpu_and_assign();
  void generate_process();
  
  std::atomic<int> cores_ready_for_next_tick_{0};
  int total_cores_{0};

  std::atomic<bool> running_;
  std::vector<std::unique_ptr<CpuWorker>> cpu_workers_; // External CpuWorker with vmstat integration

  ThreadSafeQueue<std::shared_ptr<PCB>> ready_queue_;

  mutable std::mutex running_mutex_;
  mutable std::mutex finished_mutex_;

  mutable std::mutex map_mutex_;
  std::unordered_map<std::string, std::shared_ptr<PCB>> all_processes_map_;

  std::vector<std::shared_ptr<PCB>> running_processes_;
  std::vector<std::shared_ptr<PCB>> finished_processes_;

  std::thread dispatch_thread_;

  std::atomic<bool> batch_generating_;
  std::unique_ptr<std::thread> batch_generator_thread_;
  InstructionGenerator instruction_generator_;
  int process_counter_;
  mutable std::mutex process_counter_mutex_;
  
  std::atomic<size_t> ticks_{0}; 
  mutable std::mutex clock_mutex_; 
  std::condition_variable clock_cv_; 
  std::thread global_clock_thread_;
  std::atomic<bool> tick_ready_{false};
  
  // --- NEW and MODIFIED MEMBERS for Memory Management ---
  uint32_t mem_per_proc_{4096};
  std::atomic<size_t> quantum_report_counter_{0};
  // ---------------------------------------------------

  size_t batch_process_freq_{1};
  size_t delay_per_exec_{0};
  size_t quantum_cycles_{5};
  size_t core_count_{0};
  size_t active_cores_{0};
  
  size_t maxOverallMemory{1024};
  size_t memPerFrame{64};
  size_t minMemPerProc{512};
  size_t maxMemPerProc{1024};

  size_t minInstructions{100};
  size_t maxInstructions{100};

  SchedulingAlgorithm algorithm_{SchedulingAlgorithm::FCFS};
  
  // Tracking for vmstat
  std::atomic<size_t> idle_cpu_ticks_{0};
  std::atomic<size_t> active_cpu_ticks_{0};
  std::atomic<size_t> pages_paged_in_{0};
  std::atomic<size_t> pages_paged_out_{0};

};

}  

#endif


// =====================================================================
// FILE: ./include/screen.hpp
// =====================================================================

#ifndef OSEMU_SCREEN_H_
#define OSEMU_SCREEN_H_

#include <string>
#include <vector>

#include "config.hpp"

namespace osemu {

class Scheduler;

void screen(std::vector<std::string>& args, Scheduler& scheduler, Config& config);

}  

#endif  


// =====================================================================
// FILE: ./include/thread_safe_queue.hpp
// =====================================================================

#ifndef OSEMU_THREAD_SAFE_QUEUE_H_
#define OSEMU_THREAD_SAFE_QUEUE_H_

#include <condition_variable>
#include <memory>
#include <mutex>
#include <queue>
#include <iostream>

template <typename T>
class ThreadSafeQueue {

  public:
  void push(T value) {
    std::lock_guard<std::mutex> lock(mutex_);
    queue_.push(std::move(value));
    cond_.notify_one();
  }
  
  void shutdown(){
    shutdown_requested_ = true;
    cond_.notify_all();
  }

  // Non-blocking pop: returns std::optional<T> (nullopt if empty)
  std::optional<T> try_pop() {
      std::lock_guard<std::mutex> lock(mutex_);
      if (queue_.empty()) {
          return std::nullopt;  // Return std::nullopt if queue is empty
      }
      T value = std::move(queue_.front());
      queue_.pop();
      return value;
  }

  bool wait_and_pop(T& value) {
    std::unique_lock<std::mutex> lock(mutex_);
    cond_.wait(lock, [this] { return !queue_.empty() || shutdown_requested_.load(); });
    
    if (shutdown_requested_.load() && queue_.empty()) {
      return false;
    }

    
    value = std::move(queue_.front());
    queue_.pop();
    return true;
  }

  void empty() {
    std::lock_guard lock(mutex_);
    while(!queue_.empty()){
      queue_.pop();
      std::cout << "emptied queue" << std::endl;
    }
  }

 private:
  mutable std::mutex mutex_;
  std::queue<T> queue_;
  std::condition_variable cond_;
  std::atomic_bool shutdown_requested_;
};

#endif  


// =====================================================================
// FILE: ./src/commands.cpp
// =====================================================================

#include "commands.hpp"

#include <stdexcept>
#include <string>

namespace osemu {

namespace {
using CommandMap = std::unordered_map<std::string_view, Commands>;
const CommandMap cmd_map{
    {"initialize", Commands::Initialize},
    {"screen", Commands::Screen},
    {"scheduler-start", Commands::SchedulerStart},
    {"scheduler-stop", Commands::SchedulerStop},
    {"report-util", Commands::ReportUtil},
    {"process-smi", Commands::ProcessSmi},
    {"vmstat", Commands::Vmstat},
    {"clear", Commands::Clear},
    {"exit", Commands::Exit},

};
}

Commands from_str(std::string_view cmd) {
  const auto it = cmd_map.find(cmd);
  if (it == cmd_map.end()) {
    throw std::invalid_argument("Unknown command: " + std::string{cmd});
  }
  return it->second;
}

}


// =====================================================================
// FILE: ./src/config.cpp
// =====================================================================

#include "config.hpp"

#include <algorithm>
#include <fstream>
#include <limits>
#include <stdexcept>
#include <string>

namespace osemu {

Config::Config(uint32_t cpu, SchedulingAlgorithm sched, uint32_t quantum,
               uint32_t freq, uint32_t minIns, uint32_t maxIns, uint32_t delay, uint32_t memPerFrame, uint32_t minMemPerProc, uint32_t maxMemPerProc, uint32_t maxOverallMemory)
    : cpuCount{std::clamp(cpu, 1u, 128u)},
      scheduler{sched},
      quantumCycles{
          std::clamp(quantum, 1u, std::numeric_limits<uint32_t>::max())},
      processGenFrequency{
          std::clamp(freq, 1u, std::numeric_limits<uint32_t>::max())},
      minInstructions{
          std::clamp(minIns, 1u, std::numeric_limits<uint32_t>::max())},
      maxInstructions{std::clamp(maxIns, minInstructions,
                                 std::numeric_limits<uint32_t>::max())},
      delayCyclesPerInstruction{delay},
      maxOverallMemory{std::clamp(maxOverallMemory, 1u, std::numeric_limits<uint32_t>::max())},
      memPerFrame{std::clamp(memPerFrame, 1u, std::numeric_limits<uint32_t>::max())},
      min_mem_per_proc{std::clamp(minMemPerProc, 1u, std::numeric_limits<uint32_t>::max())},
      max_mem_per_proc{std::clamp(maxMemPerProc, minMemPerProc,
                               std::numeric_limits<uint32_t>::max())} {
  if (scheduler != SchedulingAlgorithm::RoundRobin) {
    quantumCycles = 1;
  }
}

Config Config::fromFile(const std::filesystem::path& file) {
  std::ifstream in(file);
  if (!in) {
    throw std::runtime_error("Cannot open file: " + file.string());
  }

  Config cfg;
  std::string key, value;
  while (in >> key >> value) {
    if (key == "num-cpu") {
      cfg.cpuCount = std::stoul(value);
    } else if (key == "scheduler") {
      cfg.scheduler = (value == "fcfs") ? SchedulingAlgorithm::FCFS
                                        : SchedulingAlgorithm::RoundRobin;
    } else if (key == "quantum-cycles") {
      cfg.quantumCycles = std::stoul(value);
    } else if (key == "batch-process-freq") {
      cfg.processGenFrequency = std::stoul(value);
    } else if (key == "min-ins") {
      cfg.minInstructions = std::stoul(value);
    } else if (key == "max-ins") {
      cfg.maxInstructions = std::stoul(value);
    } else if (key == "delay-per-exec") {
      cfg.delayCyclesPerInstruction = std::stoul(value);
    } else if (key == "max-overall-mem"){
      cfg.max_overall_mem = std::stoul(value);
    } else if (key == "mem-per-frame"){
      cfg.mem_per_frame = std::stoul(value);
    } else if (key == "min-mem-per-proc"){
      cfg.min_mem_per_proc = std::stoul(value);
    } else if (key == "max-mem-per-proc"){
      cfg.max_mem_per_proc = std::stoul(value);
    }
  }
  return cfg;
}

}  // namespace osemu

// =====================================================================
// FILE: ./src/console.cpp
// =====================================================================

#include "console.hpp"

#include <iostream>

namespace osemu {

void console_prompt() {
  std::cout << R"(

█ ▄▄  ▄███▄     ▄▀  ███   
█   █ █▀   ▀  ▄▀    █  █  
█▀▀▀  ██▄▄    █ ▀▄  █ ▀ ▄ 
█     █▄   ▄▀ █   █ █  ▄▀ 
 █    ▀███▀    ███  ███   
  ▀                       
                          
)";
  std::cout << "\e[1;32mBy: {Paul Ivan Enclonar, Joel Ethan Batac, Joshua Gilo, Peter Parker} \n";
  std::cout << "OS Emulator v0.1\n"; 
  std::cout << "\e[1;32mHello, Welcome to PEGP Command line! \e[0m " << std::endl;
  std::cout << "\e[3;33mType 'exit' to quit, 'clear' to clear the screen.\e[0m" << std::endl;
}

}


// =====================================================================
// FILE: ./src/cpu_worker.cpp
// =====================================================================

#include "cpu_worker.h"

#include <chrono>
#include <memory>

#include "scheduler.hpp"

namespace osemu {

CpuWorker::CpuWorker(int core_id, Scheduler& scheduler)
    : core_id_(core_id), scheduler_(scheduler) {}

void CpuWorker::Start() {
  thread_ = std::thread(&CpuWorker::Run, this);
}

void CpuWorker::Stop() {
  shutdown_requested_ = true;
  condition_variable_.notify_one();
}

void CpuWorker::Join() {
  if (thread_.joinable()) {
    thread_.join();
  }
}

void CpuWorker::AssignTask(std::shared_ptr<PCB> pcb, int time_quantum) {
  std::lock_guard<std::mutex> lock(mutex_);
  time_quantum_ = time_quantum;
  ticks_with_current_task_ = 0;
  current_task_ = std::move(pcb);
  is_idle_ = false;
  condition_variable_.notify_one();
}

void CpuWorker::Run() {
  while (scheduler_.IsRunning()) {
    // Participate in barrier synchronization
    const bool tick_ready_phase = scheduler_.tick_ready_.load();
    std::unique_lock<std::mutex> barrier_lock(scheduler_.barrier_mutex_);
    
    // Wait for the Scheduler's "go" signal for this tick
    scheduler_.dispatch_go_cv_.wait(barrier_lock, [&]() {
        return scheduler_.tick_ready_ == tick_ready_phase || shutdown_requested_.load() || !scheduler_.IsRunning();
    });

    if (shutdown_requested_.load() || !scheduler_.IsRunning()) {
        break;
    }
    
    barrier_lock.unlock();
    
    // Execute one step if we have a task
    std::unique_lock<std::mutex> self_lock(mutex_);
    if (!is_idle_.load() && current_task_) {
      // Check if time quantum expired (for round-robin scheduling)
      if (time_quantum_ > 0 && ticks_with_current_task_ >= time_quantum_) {
        // Time quantum expired - preempt the process
        scheduler_.move_to_ready(current_task_);
        current_task_ = nullptr;
        is_idle_ = true;
        ticks_with_current_task_ = 0;
      } else {
        // Execute one instruction step
        InstructionExecutionInfo info = current_task_->step();
        ticks_with_current_task_++;
        
        if (info.result == InstructionResult::PROCESS_COMPLETE) {
          // Process completed
          current_task_->finishTime = std::chrono::system_clock::now();
          if (scheduler_.memory_manager_) {
            scheduler_.memory_manager_->free(current_task_->processID);
          }
          scheduler_.move_to_finished(current_task_);
          current_task_ = nullptr;
          is_idle_ = true;
          ticks_with_current_task_ = 0;
        } else if (info.result == InstructionResult::PAGE_FAULT) {
          // Handle page fault - process will be handled by memory manager
        }
        // For SUCCESS, continue executing
      }
    }
    self_lock.unlock();
    
    // Signal completion of this tick
    {
      std::unique_lock<std::mutex> signal_lock(scheduler_.barrier_mutex_);
      scheduler_.workers_completed_step_count_.fetch_add(1);
      scheduler_.workers_done_cv_.notify_one();
    } // Release the lock here

    // Wait for next tick signal (without holding barrier_mutex_)
    {
      std::unique_lock<std::mutex> wait_lock(scheduler_.barrier_mutex_);
      scheduler_.dispatch_go_cv_.wait(wait_lock, [&]() {
        return tick_ready_phase != scheduler_.tick_ready_.load() || shutdown_requested_.load() || !scheduler_.IsRunning();
      });
    }
  }
}

void CpuWorker::ExecuteProcess(std::shared_ptr<PCB> pcb, int time_quantum) {
  pcb->assignedCore = core_id_;
  scheduler_.move_to_running(pcb);
  
  size_t first_tick = scheduler_.get_ticks();
  size_t last_tick = first_tick; 
  int steps = 0;
  
  while ((time_quantum == -1 || last_tick - first_tick < time_quantum) && 
         !pcb->isComplete()) {
    if (!scheduler_.IsRunning() || shutdown_requested_.load()) {
      break;
    }

    {
      std::unique_lock<std::mutex> lock(scheduler_.GetClockMutex()); 
      
      scheduler_.GetClockCondition().wait(lock, [&]() {
        return scheduler_.get_ticks() > last_tick || 
               !scheduler_.IsRunning() || 
               shutdown_requested_.load();
      });
    }
    
    if (!scheduler_.IsRunning() || shutdown_requested_.load()) {
      break;
    }

    if (scheduler_.get_ticks() - last_tick >= scheduler_.GetDelayPerExecution()) {
      pcb->step(); 
      steps++;
    }
    last_tick = scheduler_.get_ticks();
  }

  if (pcb->isComplete()) {
    pcb->finishTime = std::chrono::system_clock::now();
    if (scheduler_.memory_manager_) {
      scheduler_.memory_manager_->free(pcb->processID);
    }
    scheduler_.move_to_finished(pcb);
  } else {
    scheduler_.move_to_ready(pcb);
  }
}

}  // namespace osemu


// =====================================================================
// FILE: ./src/dispatcher.cpp
// =====================================================================

#include "dispatcher.hpp"

#include <iostream>
#include <random>

#include "config.hpp"
#include "console.hpp"
#include "scheduler.hpp"
#include "screen.hpp"

namespace osemu {

void dispatch(Commands cmd, std::vector<std::string>& args, Config& cfg,
              Scheduler& scheduler) {

  static bool initialized = false;
  if(!initialized && cmd != Commands::Initialize){
    std::cout << "no config loaded, please call `initialize` on a config file." << std::endl;
    return;
  }
  switch (cmd) {
    case Commands::Initialize:
      try {
        initialized = true;
        scheduler.stop();
        cfg = Config::fromFile(args.empty() ? "config.txt" : args[0]);
        scheduler.start(cfg);
        std::cout << "System initialized from '" << (args.empty() ? "config.txt" : args[0]) << "'.\n";

      } catch (const std::exception& e) {
        std::cerr << "Error initializing config: " << e.what() << '\n';
      }
      break;

    case Commands::Screen:
      screen(args, scheduler, cfg);
      break;

    case Commands::SchedulerStart:
      if (scheduler.is_generating()) {
        std::cout << "Scheduler is already generating processes.\n";
      } else {
        scheduler.start_batch_generation();
      }
      break;
      
    case Commands::SchedulerStop:
      if (!scheduler.is_generating()) {
        std::cout << "Scheduler is not currently generating processes.\n";
      } else {
        scheduler.stop_batch_generation();
      }
      break;
      
    case Commands::ReportUtil:
      scheduler.generate_report();
      break;

    case Commands::ProcessSmi:
      scheduler.print_process_smi();
      break;

    case Commands::Vmstat:
      scheduler.print_vmstat();
      break;

    case Commands::Clear:
      std::cout << "\x1b[2J\x1b[H";
      console_prompt();
      break;

    case Commands::Exit:
      scheduler.stop();
      break;
  }
}




}


// =====================================================================
// FILE: ./src/instruction_evaluator.cpp
// =====================================================================

#include "instruction_evaluator.hpp"
#include "memory_manager.hpp"
#include <string>
#include <vector>
#include <memory>
#include <variant>
#include <iostream>
#include <unordered_map>
#include <format>
#include <chrono>
#include <memory>

namespace osemu {

InstructionEvaluator::InstructionEvaluator(
    std::vector<uint8_t>& heap_memory, 
    std::unordered_map<std::string, uint16_t>& symbol_table, 
    std::vector<std::string>& output_log, 
    std::string& process_name,
    uint32_t pcb_id,
    MemoryManager* memory_manager) 
    : heap_memory(heap_memory), 
    symbol_table(symbol_table), 
    output_log(output_log), 
    process_name(process_name),
    pcb_id_(pcb_id),
    memory_manager_(memory_manager) {}

uint16_t InstructionEvaluator::get_or_create_variable_address(const std::string& var_name) {
    // 1. Check if the variable already exists.
    if (symbol_table.contains(var_name)) {
        return symbol_table[var_name]; // Return its existing address.
    }

    // 2. If it doesn't exist, create it. First, check limits.
    if (symbol_table.size() >= 32) { // 32 is your symbol_table_limit
        throw std::runtime_error("Variable limit reached, cannot create: " + var_name);
    }

    // 3. Calculate the new address from the top of the heap.
    // The number of variables that will exist *after* this one is created.
    size_t new_var_count = symbol_table.size() + 1;
    
    // Check if there's enough space for another 2-byte variable.
    if (heap_memory.size() < new_var_count * 2) {
        throw std::runtime_error("Out of stack memory for new variable: " + var_name);
    }

    uint16_t new_address = heap_memory.size() - (new_var_count * 2);
    
    // 4. Add the new variable to the symbol table.
    symbol_table[var_name] = new_address;
    
    return new_address;
}

uint16_t InstructionEvaluator::read_u16_from_heap(uint16_t address) {
    // Safety check
    if (address + 1 >= heap_memory.size()) {
        std::cout << "MEMORY VIOLATION: " + std::to_string(address) << std::endl;
        throw std::runtime_error("Memory read out of bounds at address: " + std::to_string(address));
    }
    // Little-Endian read
    uint16_t upper = heap_memory[address + 1];
    uint16_t lower = heap_memory[address];
    return (upper << 8) | lower;
}

void InstructionEvaluator::write_u16_to_heap(uint16_t address, uint16_t value){
    // Safety check
    const uint16_t stack_start_address = heap_memory.size() - 64;
    if (address >= stack_start_address) {
        throw std::runtime_error("MEMORY VIOLATION: Attempt to WRITE into protected stack area at address " + std::to_string(address));
    }
    write_u16_to_mem(address, value);
}

void InstructionEvaluator::write_u16_to_mem(uint16_t address, uint16_t value) {
    if (address + 1 >= heap_memory.size()) {
        throw std::runtime_error("Memory write out of bounds at address: " + std::to_string(address));
    }

    // Little-Endian write
    heap_memory[address]     = static_cast<uint8_t>(value);
    heap_memory[address + 1] = static_cast<uint8_t>(value >> 8);
}

void InstructionEvaluator::evaluate(const Expr& expr) {
    switch (expr.type) {
        case Expr::DECLARE: {
            if (expr.var_name.empty() || !expr.atom_value) {
                throw std::runtime_error("Invalid DECLARE: missing variable name or value");
            }
            handle_declare(expr.var_name, *expr.atom_value);
            break;
        }

        case Expr::READ: {
            if (expr.var_name.empty() || !expr.atom_value){
                throw std::runtime_error("Invalid READ!");
            }
            handle_read(expr.var_name, *expr.atom_value);
            break;
        }

        case Expr::WRITE:{
            //idk how to validate this actually, this is temporary lang
            if (expr.lhs->number_value >= heap_memory.size()) {
                throw std::runtime_error("Invalid WRITE!");
            }
            handle_write(*expr.lhs, *expr.rhs);
            break;
        }
        
        case Expr::CALL: {
            if (expr.var_name == "PRINT") {
                if (expr.atom_value) { 
                    handle_print(*expr.atom_value, "");
                } else if (expr.lhs && expr.rhs) { 
                    std::string lhs_str = print_atom_to_string(*expr.lhs);
                    std::string rhs_str = print_atom_to_string(*expr.rhs);
                    Atom concatenated_atom(lhs_str + rhs_str, Atom::STRING);
                    handle_print(concatenated_atom, "");
                } else {
                    throw std::runtime_error("Invalid PRINT call: malformed arguments");
                }
            } else if (expr.var_name == "SLEEP") {
                if (!expr.atom_value) {
                    throw std::runtime_error("Invalid SLEEP call: missing argument");
                }
                handle_sleep(*expr.atom_value);
            } else {
                throw std::runtime_error("Unknown function: " + expr.var_name);
            }
            break;
        }
        
        case Expr::ADD: {
            if (expr.var_name.empty() || !expr.lhs || !expr.rhs) {
                throw std::runtime_error("Invalid ADD: missing variable name or operands");
            }
            handle_add(expr.var_name, *expr.lhs, *expr.rhs);
            break;
        }
        
        case Expr::SUB: {
            if (expr.var_name.empty() || !expr.lhs || !expr.rhs) {
                throw std::runtime_error("Invalid SUB: missing variable name or operands");
            }
            handle_sub(expr.var_name, *expr.lhs, *expr.rhs);
            break;
        }
        
        case Expr::FOR: {
            if (!expr.n) {
                throw std::runtime_error("Invalid FOR: missing loop count");
            }
            handle_for(expr.body, *expr.n);
            break;
        }
        
        case Expr::CONSTANT:
        case Expr::VOID_EXPR:
            
            break;
            
        default:
            throw std::runtime_error("Unknown expression type");
    }
}

void InstructionEvaluator::evaluate_program(const std::vector<Expr>& program) {
    for (const auto& expr : program) {
        evaluate(expr);
    }
}

//I changed this since now variables are stored in the symbol table and memory;
//Basic example of how it works say we have 128 bytes in memory right?
//Top 64 bits are allocated to the symbol table 0x40 - 0x80
//Our symbol table now stores {variable_name : address} instead of previous {variable_name : value}
//now resolve atom value basically goes heap_memory[symbol_table[variable_name]]
uint16_t InstructionEvaluator::resolve_atom_value(const Atom& atom) {
    switch (atom.type) {
        case Atom::NAME: 
        if (symbol_table.contains(atom.string_value)) {
            uint16_t address = symbol_table.at(atom.string_value);
            return read_u16_from_heap(address);
        }
        return 0; // Return 0 if variable not found.
        case Atom::NUMBER:
            return atom.number_value;
        case Atom::STRING:
            throw std::runtime_error("Cannot convert string to numeric value");
        default:
            throw std::runtime_error("Unknown atom type");
    }
}

std::string InstructionEvaluator::print_atom_to_string(const Atom& atom) {
    switch (atom.type) {
        case Atom::STRING:
            return atom.string_value;
        case Atom::NUMBER:
            return std::to_string(atom.number_value);
        case Atom::NAME: {
            // 1. Resolve the variable name to its numeric value.
            uint16_t value = resolve_atom_value(atom);
            // 2. Convert that number to a string and return it.
            return std::to_string(value);
        }
        default:
            throw std::runtime_error("Unknown atom type in print");
    }
}


void InstructionEvaluator::handle_declare(const std::string& var_name, const Atom& value) {
    uint16_t dest_address = get_or_create_variable_address(var_name);
    uint16_t value_to_store = resolve_atom_value(value);
    write_u16_to_mem(dest_address, value_to_store);
}

void InstructionEvaluator::handle_read(const std::string& var_name, const Atom& rhs) {
    uint32_t source_address;
    
    // Handle hex address parsing
    if (rhs.type == Atom::STRING && rhs.string_value.starts_with("0x")) {
        source_address = parse_hex_address(rhs.string_value);
    } else {
        source_address = rhs.number_value;
    }
    
    uint16_t value_read = 0;
    
    // Use demand paging if memory manager is available
    if (memory_manager_) {
        if (!read_u16_with_paging(source_address, value_read)) {
            // Per specification: "If the memory block isn't initialized, the uint16 value is 0"
            // Don't throw exception for invalid addresses, just use value_read = 0 (already set above)
        }
    } else {
        // Fallback to old heap memory system
        try {
            value_read = read_u16_from_heap(static_cast<uint16_t>(source_address));
        } catch (const std::runtime_error&) {
            // Per specification: return 0 for invalid/uninitialized memory addresses
            value_read = 0;
        }
    }
    
    uint16_t dest_address = get_or_create_variable_address(var_name);
    write_u16_to_mem(dest_address, value_read);
}


void InstructionEvaluator::handle_write(const Atom& address_atom, const Atom& rhs) {
    uint32_t dest_address;
    
    // Handle hex address parsing
    if (address_atom.type == Atom::STRING && address_atom.string_value.starts_with("0x")) {
        dest_address = parse_hex_address(address_atom.string_value);
    } else {
        dest_address = address_atom.number_value;
    }
    
    uint16_t value_to_write = resolve_atom_value(rhs);
    
    // Use demand paging if memory manager is available
    if (memory_manager_) {
        if (!write_u16_with_paging(dest_address, value_to_write)) {
            throw std::runtime_error("Memory access violation at address 0x" + 
                                   std::format("{:X}", dest_address));
        }
    } else {
        // Fallback to old heap memory system
        write_u16_to_heap(static_cast<uint16_t>(dest_address), value_to_write);
    }
}

std::string InstructionEvaluator::handle_print(const Atom& arg, const std::string& process_name) {
    std::string output = print_atom_to_string(arg);
    
    auto now = std::chrono::system_clock::now();
    auto truncated_time = std::chrono::time_point_cast<std::chrono::seconds>(now);
    std::string timestamp = std::format("{:%m/%d/%Y %I:%M:%S %p}", truncated_time);
 
    std::string log_entry;
    if (!process_name.empty()) {
        log_entry = std::format("({}) \"{}\"", timestamp, output);
    } else {
        log_entry = std::format("({}) \"{}\"", timestamp, output);
    }
    
    output_log.push_back(log_entry);
    return output;
}

void InstructionEvaluator::handle_sleep(const Atom& duration) {
    uint16_t cycles = resolve_atom_value(duration);
     
}

void InstructionEvaluator::handle_add(const std::string& var, const Atom& lhs, const Atom& rhs) {
    uint16_t left_val = resolve_atom_value(lhs);
    uint16_t right_val = resolve_atom_value(rhs);
    
    uint32_t result32 = static_cast<uint32_t>(left_val) + static_cast<uint32_t>(right_val);
    uint16_t result = (result32 > 65535) ? 65535 : static_cast<uint16_t>(result32);
    
    uint16_t dest_address = get_or_create_variable_address(var);
    write_u16_to_mem(dest_address, result);
}

void InstructionEvaluator::handle_sub(const std::string& var, const Atom& lhs, const Atom& rhs) {
    uint16_t left_val = resolve_atom_value(lhs);
    uint16_t right_val = resolve_atom_value(rhs);
    
    uint16_t result = (left_val >= right_val) ? (left_val - right_val) : 0;
    
    uint16_t dest_address = get_or_create_variable_address(var);
    write_u16_to_mem(dest_address, result);
}

void InstructionEvaluator::handle_for(const std::vector<Expr>& body, const Atom& count) {
    uint16_t iterations = resolve_atom_value(count);
    
    for (uint16_t i = 0; i < iterations; i++) {
        for (const auto& instruction : body) {
            evaluate(instruction);
        }
    }
}

void InstructionEvaluator::clear_variables() {
    symbol_table.clear();
}

uint16_t InstructionEvaluator::parse_hex_address(const std::string& hex_str) {
    if (hex_str.size() < 3 || hex_str.substr(0, 2) != "0x") {
        throw std::runtime_error("Invalid hex address format: " + hex_str);
    }
    
    try {
        return static_cast<uint16_t>(std::stoul(hex_str, nullptr, 16));
    } catch (const std::exception& e) {
        throw std::runtime_error("Invalid hex address: " + hex_str);
    }
}

bool InstructionEvaluator::handle_memory_access_with_paging(uint32_t virtual_address) {
    if (!memory_manager_) {
        return false;
    }
    
    // Try the access first, handle page fault if needed
    uint16_t dummy;
    if (!memory_manager_->read_from_memory(pcb_id_, virtual_address, dummy)) {
        // Page fault occurred, handle it
        return memory_manager_->handle_page_fault(pcb_id_, virtual_address);
    }
    
    return true;
}

bool InstructionEvaluator::read_u16_with_paging(uint32_t virtual_address, uint16_t& value) {
    if (!memory_manager_) {
        return false;
    }
    
    // Try to read, handle page fault if necessary
    while (!memory_manager_->read_from_memory(pcb_id_, virtual_address, value)) {
        // Page fault occurred, try to handle it
        if (!memory_manager_->handle_page_fault(pcb_id_, virtual_address)) {
            return false; // Failed to handle page fault
        }
        // Retry the read after handling page fault
    }
    
    return true;
}

bool InstructionEvaluator::write_u16_with_paging(uint32_t virtual_address, uint16_t value) {
    if (!memory_manager_) {
        return false;
    }
    
    // Try to write, handle page fault if necessary
    while (!memory_manager_->write_to_memory(pcb_id_, virtual_address, value)) {
        // Page fault occurred, try to handle it
        if (!memory_manager_->handle_page_fault(pcb_id_, virtual_address)) {
            return false; // Failed to handle page fault
        }
        // Retry the write after handling page fault
    }
    
    return true;
}

}

// =====================================================================
// FILE: ./src/instruction_generator.cpp
// =====================================================================

#include "instruction_generator.hpp"
#include <random>

namespace osemu {

InstructionGenerator::InstructionGenerator() 
    : rng(std::random_device{}()),
      instruction_type_dist(0, 5), 
      value_dist(1, 1000),
      var_name_dist(0, 25), 
      for_count_dist(1, 5),
      for_body_size_dist(1, 3),
      add_value_dist(1,10)
{
}

std::string InstructionGenerator::generateVariableName() {
    char var_char = 'a' + var_name_dist(rng);
    return std::string(1, var_char);
}

size_t InstructionGenerator::generateAddress(size_t memory_size) {
    std::random_device rd;                         // Seed source
    std::mt19937 gen(rd());                        // Mersenne Twister engine
    std::uniform_int_distribution<> dist(0, memory_size); // Distribution for memory size

    size_t address = dist(gen);

    return address;
}


Expr InstructionGenerator::generatePrintInstruction(const std::string& process_name) {
    
    std::string message = "Hello world from " + process_name + "!";
    auto atom = std::make_unique<Atom>(message, Atom::STRING);
    return Expr::make_call("PRINT", std::move(atom));
}

Expr InstructionGenerator::generateDeclareInstruction() {
    std::string var_name = generateVariableName();
    uint16_t value = value_dist(rng);
    auto atom = std::make_unique<Atom>(value);
    return Expr::make_declare(var_name, std::move(atom));
}

Expr InstructionGenerator::generateAddInstruction() {
    std::string result_var = generateVariableName();
    std::string operand1 = generateVariableName();
    uint16_t operand2_val = value_dist(rng);
    
    auto lhs = std::make_unique<Atom>(operand1, Atom::NAME);
    auto rhs = std::make_unique<Atom>(operand2_val);
    
    return Expr::make_add(result_var, std::move(lhs), std::move(rhs));
}

Expr InstructionGenerator::generateSubtractInstruction() {
    std::string result_var = generateVariableName();
    std::string operand1 = generateVariableName();
    uint16_t operand2_val = value_dist(rng);
    
    auto lhs = std::make_unique<Atom>(operand1, Atom::NAME);
    auto rhs = std::make_unique<Atom>(operand2_val);
    
    return Expr::make_sub(result_var, std::move(lhs), std::move(rhs));
}

Expr InstructionGenerator::generateSleepInstruction() {
    std::uniform_int_distribution<uint16_t> sleep_dist(1, 10); 
    uint16_t sleep_cycles = sleep_dist(rng);
    auto atom = std::make_unique<Atom>(sleep_cycles);
    return Expr::make_call("SLEEP", std::move(atom));
}

Expr InstructionGenerator::generateForInstruction(int max_depth) {
    if (max_depth <= 0) {
        
        return generatePrintInstruction("nested");
    }
    
    std::vector<Expr> body;
    int body_size = for_body_size_dist(rng);
    
    for (int i = 0; i < body_size; i++) {
        int instr_type = instruction_type_dist(rng);
        switch (instr_type) {
            case 0: body.push_back(generatePrintInstruction("loop")); break;
            case 1: body.push_back(generateDeclareInstruction()); break;
            case 2: body.push_back(generateAddInstruction()); break;
            case 3: body.push_back(generateSubtractInstruction()); break;
            case 4: body.push_back(generateSleepInstruction()); break;
            case 5: 
                if (max_depth > 1) {
                    body.push_back(generateForInstruction(max_depth - 1));
                } else {
                    body.push_back(generatePrintInstruction("nested"));
                }
                break;
        }
    }
    
    uint16_t loop_count = for_count_dist(rng);
    auto count_atom = std::make_unique<Atom>(loop_count);
    
    return Expr::make_for(std::move(body), std::move(count_atom));
}

std::vector<Expr> InstructionGenerator::generateInstructions(size_t count, const std::string& process_name, size_t memory_size) {
    std::vector<Expr> instructions;
    instructions.reserve(count);
    size_t max_address = memory_size - count - 64;
    size_t total_variables = 0;
    
    for (size_t i = 0; i < count; i++) {
        if (i % 2 == 0) {
            auto lhs = std::make_unique<Atom>("Value from: ", Atom::STRING);
            auto rhs = std::make_unique<Atom>("x", Atom::NAME);
            instructions.push_back(Expr::make_call_concat("PRINT", std::move(lhs), std::move(rhs)));
        } else if (i % 3 == 0) {
            // Generate random Write address and variable
            auto address = std::make_unique<Atom>(generateAddress(max_address));
            uint16_t value = value_dist(rng);

            instructions.push_back(Expr::make_write(std::move(address), std::make_unique<Atom>(value))); // WRITE
        } else if (i % 5 == 0) {
            // Generate random READ address and variable
            if(total_variables >= 32){
                total_variables = 0;
            }
            auto address = std::make_unique<Atom>(generateAddress(max_address));
            std::string var_name = "x" + std::to_string(total_variables++);
            
            total_variables++;
            instructions.push_back(Expr::make_read(var_name, std::move(address))); // READ
        } else {
            uint16_t add_val = add_value_dist(rng);
            auto lhs = std::make_unique<Atom>("x", Atom::NAME);
            auto rhs = std::make_unique<Atom>(add_val);
            instructions.push_back(Expr::make_add("x", std::move(lhs), std::move(rhs)));
        }
    }
    
    return instructions;
}

size_t InstructionGenerator::generate_power_of_two(size_t lower, size_t higher){
    int minExp = std::log2(lower);
    int maxExp = std::log2(higher);

    std::uniform_int_distribution<size_t> count_dist(minExp, maxExp);

    int randomExp = count_dist(rng);

    return std::pow(2, randomExp);
}

std::vector<Expr> InstructionGenerator::generateRandomProgram(size_t min_instructions, size_t max_instructions, const std::string& process_name, size_t min_mem, size_t max_mem) {
    std::uniform_int_distribution<size_t> count_dist(min_instructions, max_instructions);   
    size_t instruction_count = count_dist(rng);

    size_t mem_size = generate_power_of_two(min_mem, max_mem);
    
    return generateInstructions(instruction_count, process_name, mem_size);
}

}  


// =====================================================================
// FILE: ./src/instruction_parser.cpp
// =====================================================================

#include "instruction_parser.hpp"
#include <cctype>
#include <algorithm>
#include <stdexcept>
#include <sstream>
#include <chrono>
#include <format>

namespace osemu {

std::string InstructionParser::ltrim(const std::string& input) {
    size_t start = 0;
    while (start < input.length() && std::isspace(static_cast<unsigned char>(input[start]))) {
        start++;
    }
    return input.substr(start);
}

bool InstructionParser::consume_tag(const std::string& input, const std::string& tag, std::string& remaining) {
    std::string trimmed = ltrim(input);
    if (trimmed.length() >= tag.length() && trimmed.substr(0, tag.length()) == tag) {
        remaining = trimmed.substr(tag.length());
        return true;
    }
    return false;
}

ParseResult InstructionParser::parse_string(const std::string& input, Atom& result) {
    std::string trimmed = ltrim(input);
    
    if (trimmed.empty() || trimmed[0] != '"') {
        return ParseResult(false, trimmed, "Expected opening quote");
    }
    
    size_t i = 1;
    while (i < trimmed.length() && trimmed[i] != '"') {
        i++;
    }
    
    if (i >= trimmed.length()) {
        return ParseResult(false, trimmed, "Expected closing quote");
    }
    
    std::string str_content = trimmed.substr(1, i - 1);
    result = Atom(str_content, Atom::STRING);
    
    return ParseResult(true, trimmed.substr(i + 1));
}

ParseResult InstructionParser::parse_name(const std::string& input, Atom& result) {
    std::string trimmed = ltrim(input);
    
    if (trimmed.empty() || !std::isalpha(static_cast<unsigned char>(trimmed[0]))) {
        return ParseResult(false, trimmed, "Expected alphabetic character");
    }
    
    size_t i = 0;
    while (i < trimmed.length() && std::isalpha(static_cast<unsigned char>(trimmed[i]))) {
        i++;
    }
    
    std::string name = trimmed.substr(0, i);
    result = Atom(name, Atom::NAME);
    
    return ParseResult(true, trimmed.substr(i));
}

ParseResult InstructionParser::parse_number(const std::string& input, Atom& result) {
    std::string trimmed = ltrim(input);
    
    if (trimmed.empty() || !std::isdigit(static_cast<unsigned char>(trimmed[0]))) {
        return ParseResult(false, trimmed, "Expected digit");
    }
    
    size_t i = 0;
    while (i < trimmed.length() && std::isdigit(static_cast<unsigned char>(trimmed[i]))) {
        i++;
    }
    
    std::string number_str = trimmed.substr(0, i);
    try {
        unsigned long number_val = std::stoul(number_str);
        if (number_val > 65535) {
            return ParseResult(false, trimmed, "Number out of range for uint16_t");
        }
        result = Atom(static_cast<uint16_t>(number_val));
    } catch (const std::invalid_argument&) {
        return ParseResult(false, trimmed, "Invalid number format");
    } catch (const std::out_of_range&) {
        return ParseResult(false, trimmed, "Number out of range for uint16_t");
    }
    
    return ParseResult(true, trimmed.substr(i));
}

ParseResult InstructionParser::parse_address(const std::string& input, Atom& result) {
    std::string trimmed = ltrim(input);
    size_t pos = 0; // Will be updated by stoull to show how many chars were parsed
    try {
        // stoull will parse hex if the string starts with 0x and base is 0.
        // We use base 0 for auto-detection.
        unsigned long long number_val = std::stoull(trimmed, &pos, 0);

        // After the call, we check if it actually parsed a hex number.
        // 1. `pos` must be > 2 (at least "0x" and one digit).
        // 2. The original string must start with "0x" or "0X".
        if (pos < 3 || (trimmed.substr(0, 2) != "0x" && trimmed.substr(0, 2) != "0X")) {
            // It might have parsed a decimal or octal number, which we don't want.
            return ParseResult(false, trimmed, "Address must be a hexadecimal number starting with 0x");
        }
        
        if (number_val > 65535) {
            return ParseResult(false, trimmed, "Address value out of range for uint16_t");
        }
        
        result = Atom(static_cast<uint16_t>(number_val));
        
        // The remaining string is the original trimmed string starting from `pos`.
        return ParseResult(true, trimmed.substr(pos));

    } catch (const std::invalid_argument&) {
        // stoull throws this if no conversion could be performed at all.
        return ParseResult(false, trimmed, "Invalid address format");
    } catch (const std::out_of_range&) {
        // stoull throws this if the number is too big for an unsigned long long.
        return ParseResult(false, trimmed, "Address value out of range for uint16_t");
    }
}

ParseResult InstructionParser::parse_atom(const std::string& input, Atom& result) {
    std::string trimmed = ltrim(input);
    
    ParseResult string_result = parse_string(trimmed, result);
    if (string_result.success) {
        return string_result;
    }
    
    ParseResult name_result = parse_name(trimmed, result);
    if (name_result.success) {
        return name_result;
    }

    ParseResult address_result = parse_address(trimmed, result);
    if (address_result.success){
        return address_result;
    }
    
    ParseResult number_result = parse_number(trimmed, result);
    if (number_result.success) {
        return number_result;
    }
    
    return ParseResult(false, trimmed, "Expected string, name, or number");
}

ParseResult InstructionParser::parse_declare(const std::string& input, Expr& result) {
    std::string remaining;
    if (!consume_tag(input, "DECLARE", remaining)) {
        return ParseResult(false, input, "Expected DECLARE");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }
    
    Atom name_atom(0);
    ParseResult name_result = parse_name(remaining, name_atom);
    if (!name_result.success) {
        return ParseResult(false, remaining, "Expected variable name");
    }
    remaining = name_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom value_atom(0);
    ParseResult value_result = parse_atom(remaining, value_atom);
    if (!value_result.success) {
        return ParseResult(false, remaining, "Expected value");
    }
    remaining = value_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    result = Expr::make_declare(name_atom.string_value, 
                               std::make_unique<Atom>(value_atom));
    
    return ParseResult(true, remaining);
}

ParseResult InstructionParser::parse_add(const std::string& input, Expr& result) {
    std::string remaining;
    if (!consume_tag(input, "ADD", remaining)) {
        return ParseResult(false, input, "Expected ADD");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }
    
    Atom var_atom(0);
    ParseResult var_result = parse_name(remaining, var_atom);
    if (!var_result.success) {
        return ParseResult(false, remaining, "Expected variable name");
    }
    remaining = var_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom lhs_atom(0);
    ParseResult lhs_result = parse_atom(remaining, lhs_atom);
    if (!lhs_result.success) {
        return ParseResult(false, remaining, "Expected left operand");
    }
    remaining = lhs_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom rhs_atom(0);
    ParseResult rhs_result = parse_atom(remaining, rhs_atom);
    if (!rhs_result.success) {
        return ParseResult(false, remaining, "Expected right operand");
    }
    remaining = rhs_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    result = Expr::make_add(var_atom.string_value,
                           std::make_unique<Atom>(lhs_atom),
                           std::make_unique<Atom>(rhs_atom));
    
    return ParseResult(true, remaining);
}

ParseResult InstructionParser::parse_sub(const std::string& input, Expr& result) {
    std::string remaining;
    if (!consume_tag(input, "SUBTRACT", remaining)) {
        return ParseResult(false, input, "Expected SUBTRACT");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }
    
    Atom var_atom(0);
    ParseResult var_result = parse_name(remaining, var_atom);
    if (!var_result.success) {
        return ParseResult(false, remaining, "Expected variable name");
    }
    remaining = var_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom lhs_atom(0);
    ParseResult lhs_result = parse_atom(remaining, lhs_atom);
    if (!lhs_result.success) {
        return ParseResult(false, remaining, "Expected left operand");
    }
    remaining = lhs_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom rhs_atom(0);
    ParseResult rhs_result = parse_atom(remaining, rhs_atom);
    if (!rhs_result.success) {
        return ParseResult(false, remaining, "Expected right operand");
    }
    remaining = rhs_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    result = Expr::make_sub(var_atom.string_value,
                           std::make_unique<Atom>(lhs_atom),
                           std::make_unique<Atom>(rhs_atom));
    
    return ParseResult(true, remaining);
}


ParseResult InstructionParser::parse_read(const std::string& input, Expr& result){
    std::string remaining;
    if (!consume_tag(input, "READ", remaining)) {
        return ParseResult(false, input, "Expected READ");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }
    
    Atom var_atom(0);
    ParseResult var_result = parse_name(remaining, var_atom);
    if (!var_result.success) {
        return ParseResult(false, remaining, "Expected variable name");
    }
    remaining = var_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom address_atom(0);
    ParseResult address_result = parse_atom(remaining, address_atom);
    if (!address_result.success) {
        return ParseResult(false, remaining, "Expected address value");
    }
    remaining = address_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    // Assuming Expr::make_read(string var_name, unique_ptr<Atom> address) exists
    result = Expr::make_read(var_atom.string_value, 
                             std::make_unique<Atom>(address_atom));
    
    return ParseResult(true, remaining);
}

ParseResult InstructionParser::parse_write(const std::string& input, Expr& result){
    std::string remaining;
    if (!consume_tag(input, "WRITE", remaining)) {
        return ParseResult(false, input, "Expected WRITE");
    }

    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }

    Atom address_atom(0);
    ParseResult address_result = parse_atom(remaining, address_atom);
    if (!address_result.success) {
        return ParseResult(false, remaining, "Expected address value");
    }
    remaining = address_result.remaining;

    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }

    Atom value_atom(0);
    ParseResult value_result = parse_atom(remaining, value_atom);
    if (!value_result.success) {
        return ParseResult(false, remaining, "Expected value to write (variable or literal)");
    }
    remaining = value_result.remaining;

    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    // Assuming Expr::make_write(unique_ptr<Atom> address, unique_ptr<Atom> value) exists
    result = Expr::make_write(std::make_unique<Atom>(address_atom),
                              std::make_unique<Atom>(value_atom));

    return ParseResult(true, remaining);
}


ParseResult InstructionParser::parse_call(const std::string& input, Expr& result) {
    std::string trimmed = ltrim(input);
    
    Atom name_atom(0);
    ParseResult name_result = parse_name(trimmed, name_atom);
    if (!name_result.success) {
        return ParseResult(false, trimmed, "Expected function name");
    }
    std::string remaining = name_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }
    
    
    Atom lhs_atom(0);
    ParseResult lhs_res = parse_atom(remaining, lhs_atom);
    if (lhs_res.success) {
        std::string temp_remaining = ltrim(lhs_res.remaining);
        if (!temp_remaining.empty() && temp_remaining[0] == '+') {
            consume_tag(temp_remaining, "+", temp_remaining); 
            
            Atom rhs_atom(0);
            ParseResult rhs_res = parse_atom(ltrim(temp_remaining), rhs_atom);
            if (!rhs_res.success) {
                return ParseResult(false, temp_remaining, "Expected right-hand side for concatenation");
            }
            
            remaining = ltrim(rhs_res.remaining);
            if (!consume_tag(remaining, ")", remaining)) {
                return ParseResult(false, remaining, "Expected closing parenthesis after concatenation");
            }
            
            result = Expr::make_call_concat(name_atom.string_value, 
                                            std::make_unique<Atom>(lhs_atom),
                                            std::make_unique<Atom>(rhs_atom));
            return ParseResult(true, remaining);
        }
    }

    
    Atom arg_atom(0);
    ParseResult arg_result = parse_atom(remaining, arg_atom);
    if (!arg_result.success) {
        return ParseResult(false, remaining, "Expected argument");
    }
    remaining = arg_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    result = Expr::make_call(name_atom.string_value,
                            std::make_unique<Atom>(arg_atom));
    
    return ParseResult(true, remaining);
}

ParseResult InstructionParser::parse_for(const std::string& input, Expr& result) {
    std::string remaining;
    if (!consume_tag(input, "FOR", remaining)) {
        return ParseResult(false, input, "Expected FOR");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "(", remaining)) {
        return ParseResult(false, remaining, "Expected opening parenthesis");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, "[", remaining)) {
        return ParseResult(false, remaining, "Expected opening bracket");
    }
    
    std::vector<Expr> body;
    remaining = ltrim(remaining);
    
    while (!remaining.empty() && remaining[0] != ']') {
        Expr expr(Expr::VOID_EXPR);
        ParseResult expr_result = parse_expr(remaining, expr);
        if (!expr_result.success) {
            break;
        }
        body.push_back(std::move(expr));
        remaining = ltrim(expr_result.remaining);
        
        if (!remaining.empty() && remaining[0] == ',') {
            remaining = remaining.substr(1);
            remaining = ltrim(remaining);
        }
    }
    
    if (!consume_tag(remaining, "]", remaining)) {
        return ParseResult(false, remaining, "Expected closing bracket");
    }
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ",", remaining)) {
        return ParseResult(false, remaining, "Expected comma");
    }
    
    Atom n_atom(0);
    ParseResult n_result = parse_atom(remaining, n_atom);
    if (!n_result.success) {
        return ParseResult(false, remaining, "Expected loop count");
    }
    remaining = n_result.remaining;
    
    remaining = ltrim(remaining);
    if (!consume_tag(remaining, ")", remaining)) {
        return ParseResult(false, remaining, "Expected closing parenthesis");
    }
    
    result = Expr::make_for(std::move(body), std::make_unique<Atom>(n_atom));
    
    return ParseResult(true, remaining);
}

ParseResult InstructionParser::parse_expr(const std::string& input, Expr& result) {
    std::string trimmed = ltrim(input);
    
    ParseResult declare_result = parse_declare(trimmed, result);
    if (declare_result.success) {
        return declare_result;
    }
    
    ParseResult add_result = parse_add(trimmed, result);
    if (add_result.success) {
        return add_result;
    }
    
    ParseResult sub_result = parse_sub(trimmed, result);
    if (sub_result.success) {
        return sub_result;
    }
    
    ParseResult for_result = parse_for(trimmed, result);
    if (for_result.success) {
        return for_result;
    }
    
    ParseResult call_result = parse_call(trimmed, result);
    if (call_result.success) {
        return call_result;
    }

    ParseResult read_result = parse_read(trimmed, result);
    if (read_result.success){
        return read_result;
    }

    ParseResult write_result = parse_write(trimmed, result);
    if(write_result.success){
        return write_result;
    }
    
    return ParseResult(false, trimmed, "Expected expression");
}

ParseResult InstructionParser::parse_program(const std::string& input, std::vector<Expr>& result) {
    std::string remaining = input;
    result.clear();
    
    while (!remaining.empty()) {
        remaining = ltrim(remaining);
        if (remaining.empty()) {
            break;
        }
        
        Expr expr(Expr::VOID_EXPR);
        ParseResult expr_result = parse_expr(remaining, expr);
        if (!expr_result.success) {
            return ParseResult(false, remaining, expr_result.error_msg);
        }
        
        result.push_back(std::move(expr));
        remaining = expr_result.remaining;
    }
    
    return ParseResult(true, remaining);
}

}  


// =====================================================================
// FILE: ./src/main.cpp
// =====================================================================

#include <iostream>
#include <memory>
#include <string>

#include "commands.hpp"
#include "config.hpp"
#include "console.hpp"
#include "dispatcher.hpp"
#include "parser.hpp"
#include "process_control_block.hpp"
#include "scheduler.hpp"


int main() {
  using namespace osemu;


  Config cfg;
  Scheduler scheduler;
  console_prompt();

  std::string line;
  while (std::cout << "~ " << std::flush && std::getline(std::cin, line)) {
    auto tokens = ParseTokens(line);
    if (tokens.empty()) {
      continue;
    }

    try {
      Commands cmd = from_str(tokens.front());

      tokens.erase(tokens.begin());
      dispatch(cmd, tokens, cfg, scheduler);

      if (cmd == Commands::Exit) {
        break;
      }


    } catch (const std::exception& ex) {
      std::cerr << "Error: " << ex.what() << '\n';
    }
  }

  std::cout << "Emulator has shut down cleanly." << std::endl;
  return 0;
}


// =====================================================================
// FILE: ./src/memory_manager.cpp
// =====================================================================

#include "memory_manager.hpp"

#include <chrono>
#include <format>
#include <fstream>
#include <iomanip>
#include <iostream>

namespace osemu {

// --- Constructor, allocate, free, coalesce_free_blocks are unchanged ---

MemoryManager::MemoryManager(uint32_t total_size, uint32_t frame_size)
    : total_memory_size_(total_size), frame_size_(frame_size), 
      num_frames_(total_size / frame_size), backing_store_filename_("csopesy-backing-store.txt") {
    memory_map_.push_back({0, total_memory_size_, true, 0});
    
    // Initialize frames
    frames_.reserve(num_frames_);
    for (uint32_t i = 0; i < num_frames_; ++i) {
        frames_.emplace_back(i, frame_size_);
    }
    
    std::cout << "Memory Manager initialized with " << total_size << " bytes (" 
              << num_frames_ << " frames of " << frame_size_ << " bytes each)." << std::endl;
}

bool MemoryManager::allocate(uint32_t pcb_id, uint32_t size,
                             std::shared_ptr<PCB> pcb) {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    for (auto it = memory_map_.begin(); it != memory_map_.end(); ++it) {
        if (it->is_free && it->size >= size) {
            if (it->size > size) {
                uint32_t remaining_size = it->size - size;
                uint32_t new_block_start = it->start_address + size;
                MemoryBlock new_free_block = {new_block_start, remaining_size, true, 0, nullptr};
                it->size = size;
                it->is_free = false;
                it->pcb_id = pcb_id;
                it->pcb_block = pcb;
                memory_map_.insert(std::next(it), new_free_block);
            } else {
                it->is_free = false;
                it->pcb_id = pcb_id;
                it->pcb_block = pcb;
            }
            // std::cout << "Allocated " << size << " bytes for PID " << pcb_id << " at address " << it->start_address << std::endl;
            return true;
        }
    }
    // std::cout << "Failed to allocate " << size << " bytes for PID " << pcb_id << ". No sufficient memory." << std::endl;
    return false;
}

void MemoryManager::free(uint32_t pcb_id) {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    for (auto it = memory_map_.begin(); it != memory_map_.end(); ++it) {
        if (!it->is_free && it->pcb_id == pcb_id) {
            // std::cout << "Freeing memory for PID " << pcb_id << " at address " << it->start_address << std::endl;
            it->is_free = true;
            it->pcb_id = 0;
            it->pcb_block = nullptr;
            //coalesce_free_blocks(it);
            return;
        }
    }
}

void MemoryManager::coalesce_free_blocks(std::list<MemoryBlock>::iterator newly_freed_block) {
    auto next_block = std::next(newly_freed_block);
    if (next_block != memory_map_.end() && next_block->is_free) {
        newly_freed_block->size += next_block->size;
        memory_map_.erase(next_block);
    }
    if (newly_freed_block != memory_map_.begin()) {
        auto prev_block = std::prev(newly_freed_block);
        if (prev_block->is_free) {
            prev_block->size += newly_freed_block->size;
            memory_map_.erase(newly_freed_block);
        }
    }
}

// --- NEW METHOD IMPLEMENTATION ---
bool MemoryManager::is_allocated(uint32_t pcb_id) const {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    for (const auto& block : memory_map_) {
        if (!block.is_free && block.pcb_id == pcb_id) {
            return true; // Found the process in memory.
        }
    }
    return false; // Process not found in memory.
}


void MemoryManager::write_memory_report(std::ostream& out) const {
  std::lock_guard<std::mutex> lock(memory_mutex_);

  auto now = std::chrono::time_point_cast<std::chrono::seconds>(std::chrono::system_clock::now());
  out << "Timestamp: " << std::format("{:%m/%d/%Y %I:%M:%S %p}", now) << "\n";

  size_t procs_in_mem = 0;
  uint32_t external_frag_bytes = 0;
  uint32_t total_used_bytes = 0;

  for (const auto& block : memory_map_) {
    if (!block.is_free) {
      procs_in_mem++;
      total_used_bytes += block.size;
    } else {
      external_frag_bytes += block.size;
    }
  }

  double utilization = 100.0 * static_cast<double>(total_used_bytes) / static_cast<double>(total_memory_size_);

  out << "Number of processes in memory: " << procs_in_mem << "\n";
  out << "Total external fragmentation in KB: " << std::fixed << std::setprecision(2)
      << (static_cast<double>(external_frag_bytes) / 1024.0) << "\n";
  out << "Memory used (bytes): " << total_used_bytes << " / " << total_memory_size_ << "\n";
  out << "Memory utilization: " << std::fixed << std::setprecision(2) << utilization << "%\n\n";

  out << std::format("----end---- = {}\n", total_memory_size_);

  for (auto it = memory_map_.rbegin(); it != memory_map_.rend(); ++it) {
    const auto& block = *it;
    if (!block.is_free) {
      out << block.start_address + block.size << "\n";
      if (block.pcb_block) {
        out << std::format("P{:02d} | {}\n", block.pcb_id, block.pcb_block->processName);
      } else {
        out << std::format("P{:02d} | [null PCB]\n", block.pcb_id);
      }
      out << block.start_address << "\n\n";
    }
  }

  out << std::format("----start---- = {}\n", 0);
}


void MemoryManager::generate_memory_report(const std::string& filename) const {
    std::ofstream report_file(filename);
    if (!report_file) {
        std::cerr << "Error: Could not open report file " << filename << std::endl;
        return;
    }
    write_memory_report(report_file);
}

void MemoryManager::generate_memory_report(std::ostream& out) const {
    write_memory_report(out);
}

void MemoryManager::initialize_page_table(uint32_t pcb_id, uint32_t num_pages) {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    page_tables_[pcb_id] = std::vector<PageTableEntry>(num_pages);
}

bool MemoryManager::handle_page_fault(uint32_t pcb_id, uint32_t virtual_address) {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    
    uint32_t page_id = virtual_address / frame_size_;
    
    // Check if page table exists
    if (page_tables_.find(pcb_id) == page_tables_.end()) {
        return false;
    }
    
    auto& page_table = page_tables_[pcb_id];
    if (page_id >= page_table.size()) {
        return false; // Invalid page access
    }
    
    // Allocate a frame
    uint32_t frame_id = allocate_frame();
    if (frame_id == UINT32_MAX) {
        // No free frames, need to evict
        frame_id = find_victim_frame();
        evict_page(frame_id);
    }
    
    // Load page from backing store
    std::vector<uint8_t> page_data(frame_size_, 0);
    if (load_page_from_backing_store(pcb_id, page_id, page_data)) {
        pages_paged_in_++;
    }
    
    // Update frame and page table
    frames_[frame_id].is_free = false;
    frames_[frame_id].pcb_id = pcb_id;
    frames_[frame_id].page_id = page_id;
    frames_[frame_id].data = page_data;
    
    page_table[page_id].is_valid = true;
    page_table[page_id].frame_id = frame_id;
    page_table[page_id].is_referenced = true;
    
    return true;
}

bool MemoryManager::read_from_memory(uint32_t pcb_id, uint32_t virtual_address, uint16_t& value) {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    
    uint32_t page_id = virtual_address / frame_size_;
    uint32_t offset = virtual_address % frame_size_;
    
    if (page_tables_.find(pcb_id) == page_tables_.end()) {
        return false;
    }
    
    auto& page_table = page_tables_[pcb_id];
    if (page_id >= page_table.size() || !page_table[page_id].is_valid) {
        return false; // Page fault should be handled externally
    }
    
    uint32_t frame_id = page_table[page_id].frame_id;
    page_table[page_id].is_referenced = true;
    
    if (offset + 1 >= frame_size_) {
        return false; // Invalid access
    }
    
    // Read uint16 from frame data
    value = static_cast<uint16_t>(frames_[frame_id].data[offset]) |
            (static_cast<uint16_t>(frames_[frame_id].data[offset + 1]) << 8);
    
    return true;
}

bool MemoryManager::write_to_memory(uint32_t pcb_id, uint32_t virtual_address, uint16_t value) {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    
    uint32_t page_id = virtual_address / frame_size_;
    uint32_t offset = virtual_address % frame_size_;
    
    if (page_tables_.find(pcb_id) == page_tables_.end()) {
        return false;
    }
    
    auto& page_table = page_tables_[pcb_id];
    if (page_id >= page_table.size() || !page_table[page_id].is_valid) {
        return false; // Page fault should be handled externally
    }
    
    uint32_t frame_id = page_table[page_id].frame_id;
    page_table[page_id].is_referenced = true;
    page_table[page_id].is_dirty = true;
    
    if (offset + 1 >= frame_size_) {
        return false; // Invalid access
    }
    
    // Write uint16 to frame data
    frames_[frame_id].data[offset] = static_cast<uint8_t>(value & 0xFF);
    frames_[frame_id].data[offset + 1] = static_cast<uint8_t>((value >> 8) & 0xFF);
    
    return true;
}

uint32_t MemoryManager::allocate_frame() {
    for (uint32_t i = 0; i < num_frames_; ++i) {
        if (frames_[i].is_free) {
            return i;
        }
    }
    return UINT32_MAX; // No free frame
}

uint32_t MemoryManager::find_victim_frame() {
    // Simple LRU approximation: find least recently referenced frame
    for (uint32_t i = 0; i < num_frames_; ++i) {
        if (!frames_[i].is_free) {
            uint32_t pcb_id = frames_[i].pcb_id;
            uint32_t page_id = frames_[i].page_id;
            
            if (page_tables_.find(pcb_id) != page_tables_.end()) {
                auto& page_table = page_tables_[pcb_id];
                if (page_id < page_table.size() && !page_table[page_id].is_referenced) {
                    return i;
                }
            }
        }
    }
    
    // If all pages are referenced, clear reference bits and return first frame
    for (uint32_t i = 0; i < num_frames_; ++i) {
        if (!frames_[i].is_free) {
            uint32_t pcb_id = frames_[i].pcb_id;
            uint32_t page_id = frames_[i].page_id;
            
            if (page_tables_.find(pcb_id) != page_tables_.end()) {
                auto& page_table = page_tables_[pcb_id];
                if (page_id < page_table.size()) {
                    page_table[page_id].is_referenced = false;
                }
            }
        }
    }
    
    return 0; // Return first frame as victim
}

void MemoryManager::evict_page(uint32_t frame_id) {
    if (frame_id >= num_frames_ || frames_[frame_id].is_free) {
        return;
    }
    
    uint32_t pcb_id = frames_[frame_id].pcb_id;
    uint32_t page_id = frames_[frame_id].page_id;
    
    // Save to backing store if dirty
    if (page_tables_.find(pcb_id) != page_tables_.end()) {
        auto& page_table = page_tables_[pcb_id];
        if (page_id < page_table.size() && page_table[page_id].is_dirty) {
            save_page_to_backing_store(pcb_id, page_id, frames_[frame_id].data);
            pages_paged_out_++;
        }
        
        // Invalidate page table entry
        page_table[page_id].is_valid = false;
        page_table[page_id].is_dirty = false;
        page_table[page_id].is_referenced = false;
    }
    
    // Mark frame as free
    frames_[frame_id].is_free = true;
    frames_[frame_id].pcb_id = 0;
    frames_[frame_id].page_id = 0;
}

void MemoryManager::save_page_to_backing_store(uint32_t pcb_id, uint32_t page_id, const std::vector<uint8_t>& data) {
    std::ofstream file(backing_store_filename_, std::ios::binary | std::ios::app);
    if (file) {
        file.write(reinterpret_cast<const char*>(&pcb_id), sizeof(pcb_id));
        file.write(reinterpret_cast<const char*>(&page_id), sizeof(page_id));
        file.write(reinterpret_cast<const char*>(data.data()), data.size());
    }
}

bool MemoryManager::load_page_from_backing_store(uint32_t pcb_id, uint32_t page_id, std::vector<uint8_t>& data) {
    std::ifstream file(backing_store_filename_, std::ios::binary);
    if (!file) {
        return false;
    }
    
    uint32_t stored_pcb_id, stored_page_id;
    while (file.read(reinterpret_cast<char*>(&stored_pcb_id), sizeof(stored_pcb_id)) &&
           file.read(reinterpret_cast<char*>(&stored_page_id), sizeof(stored_page_id))) {
        
        if (stored_pcb_id == pcb_id && stored_page_id == page_id) {
            file.read(reinterpret_cast<char*>(data.data()), data.size());
            return true;
        } else {
            file.seekg(frame_size_, std::ios::cur); // Skip this page
        }
    }
    
    return false;
}

uint32_t MemoryManager::get_used_memory() const {
    std::lock_guard<std::mutex> lock(memory_mutex_);
    uint32_t used = 0;
    // Check memory_map_ for traditional memory allocation
    for (const auto& block : memory_map_) {
        if (!block.is_free) {
            used += block.size;
        }
    }
    return used;
}

uint32_t MemoryManager::get_free_memory() const {
    return total_memory_size_ - get_used_memory();
}

}

// =====================================================================
// FILE: ./src/parser.cpp
// =====================================================================

#include "parser.hpp"

#include <sstream>

namespace osemu {

std::vector<std::string> ParseTokens(const std::string& line) {
  std::istringstream iss(line);
  std::vector<std::string> tokens;
  std::string token;

  while (iss >> token) {
    //if token starts with a ", start another chain until find a token that ends with "
    if(token.starts_with('"')){
      std::string subtoken;
      while(iss >> subtoken){
        token.append(" " + subtoken);
        if(subtoken.ends_with('"') && !subtoken.ends_with("\\\"")){
          break;
        }
      }
    }
    tokens.push_back(token);
  }

  return tokens;
}

}


// =====================================================================
// FILE: ./src/process_control_block.cpp
// =====================================================================

#include "process_control_block.hpp"

#include <format>
#include <sstream>

namespace osemu {
std::atomic<uint32_t> PCB::next_pid{1}; 

PCB::PCB(std::string procName, size_t totalLines, MemoryManager* memory_manager)
    : processID(next_pid++),
      processName(std::move(procName)),
      currentInstruction(0),
      totalInstructions(totalLines),
      creationTime(std::chrono::system_clock::now()),
      assignedCore(std::nullopt),
      sleepCyclesRemaining(0),
      evaluator(std::make_unique<InstructionEvaluator>(
          this->heap_memory,
          this->symbol_table,
          this->output_log,
          this->processName,
          this->processID,
          memory_manager
      ))

{
  evaluator->handle_declare("x", Atom(static_cast<uint16_t>(0)));
}

PCB::PCB(std::string procName, const std::vector<Expr>& instrs, MemoryManager* memory_manager)
    : processID(next_pid++),
      processName(std::move(procName)),
      currentInstruction(0),
      totalInstructions(instrs.size()),
      creationTime(std::chrono::system_clock::now()),
      assignedCore(std::nullopt),
      sleepCyclesRemaining(0),
      instructions(instrs),
      evaluator(std::make_unique<InstructionEvaluator>(
          this->heap_memory,
          this->symbol_table,
          this->output_log,
          this->processName,
          this->processID,
          memory_manager
      ))
        
{
  evaluator->handle_declare("x", Atom(static_cast<uint16_t>(0)));
} //BTW I DONT GET PARA SAN YUNG MGA HANDLE_DECLARE HERE, 

PCB::PCB(std::string procName, const std::vector<Expr>& instrs, size_t memory_size, MemoryManager* memory_manager)
    : processID(next_pid++),
      processName(std::move(procName)),
      currentInstruction(0),
      totalInstructions(instrs.size()),
      creationTime(std::chrono::system_clock::now()),
      assignedCore(std::nullopt),
      sleepCyclesRemaining(0),
      instructions(instrs),
      heap_memory(memory_size, 0), // no need to subtract 64 since we're already taking that into account!
      evaluator(std::make_unique<InstructionEvaluator>(
          this->heap_memory,
          this->symbol_table,
          this->output_log,
          this->processName,
          this->processID,
          memory_manager
      ))
{
  evaluator->handle_declare("x", Atom(static_cast<uint16_t>(0)));
}

//
// PCB::PCB(std::string procName, const std::vector<Expr>& instrs, size_t memory_size)
//     : processID(next_pid++),
//       processName(std::move(procName)),
//       currentInstruction(0),
//       totalInstructions(instrs.size()),
//       creationTime(std::chrono::system_clock::now()),
//       assignedCore(std::nullopt),
//       sleepCyclesRemaining(0),
//       instructions(instrs),
//       heap_memory(memory_size - (instrs.size() - 64), 0)
// {
//   evaluator->handle_declare("x", Atom(static_cast<uint16_t>(0)));
// }

InstructionExecutionInfo PCB::step() {
  if (isSleeping()) {
    decrementSleepCycles();
    return InstructionExecutionInfo();
  }
  
  if (currentInstruction < instructions.size()) {
    executeCurrentInstruction();
    ++currentInstruction;
  } else if (isComplete()){
    return InstructionExecutionInfo(InstructionResult::PROCESS_COMPLETE, 0);
  }
  return InstructionExecutionInfo();
}


bool PCB::isComplete() const { return currentInstruction >= totalInstructions; }



std::string PCB::status() const {
  
  auto truncated_creation_time = std::chrono::time_point_cast<std::chrono::seconds>(creationTime); 
  auto creation_time_str = std::format("{:%m/%d/%Y %I:%M:%S %p}", truncated_creation_time);

  std::ostringstream oss;
  oss << "PID:" << processID << " " << processName << " (" << creation_time_str << ")  ";

  
  if (isComplete()) {
    
    oss << "Finished           " << totalInstructions << " / "
        << totalInstructions;

  } else if (assignedCore.has_value()) {
    oss << "Core: " << *assignedCore << "            " << currentInstruction
        << " / " << totalInstructions;
  } else {
    oss << "Ready (in queue)   " << currentInstruction << " / "
        << totalInstructions;
  }
  return oss.str();
}

bool PCB::executeCurrentInstruction() {
  if (currentInstruction >= instructions.size()) {
    return false;
  }
  
  try {
    const auto& instr = instructions[currentInstruction];
    if (instr.type == Expr::CALL && instr.var_name == "SLEEP" && instr.atom_value) {
      uint16_t cycles = evaluator->resolve_atom_value(*instr.atom_value);
      setSleepCycles(cycles);
      return true;
    }

    // Remove old READ/WRITE handlers - let InstructionEvaluator handle them consistently    
    
    //WHY ARE WE IMPLEMENTING THESE FUNCTIONS HERE HERE?
    //if (instr.type == Expr::READ){
    //  if (symbol_table_size >= symbol_table_limit) {
    //    throw std::runtime_error("Symbol table limit reached"); 
    //    return true;
    //  }
    //  else if (instr.atom_value->number_value >= heap_memory.size()) {
    //    throw std::runtime_error("Heap address out of bounds");
    //    return true;
    //    // violation error and then shut down the process
    //  } else {
    //    // check if logic is good
    //    symbol_table[instr.var_name] = heap_memory[instr.atom_value->number_value];
    //    Atom temp_atom("READ operation: " + instr.var_name + " = " + std::to_string(symbol_table[instr.var_name]), Atom::STRING);
    //    symbol_table_size++;
    //    evaluator->handle_print(temp_atom, processName);
    //    return true;
    //  }
    //}

    //if (instr.type == Expr::WRITE) {
    //  // check if heap address is valid
    //  if (instr.lhs->number_value >= heap_memory.size()) {
    //    throw std::runtime_error("Heap address out of bounds");
    //    return true;
    //    // violation error and then shut down the process
    //  }
    //  // check if logic is good
    //  heap_memory[instr.lhs->number_value] = instr.rhs->number_value;
    //  Atom temp_atom("WRITE operation: " + std::to_string(instr.lhs->number_value) + " = " + std::to_string(instr.rhs->number_value), Atom::STRING);
    //  evaluator->handle_print(temp_atom, processName);
    //  return true;
    //}    
    
    
    if (instr.type == Expr::CALL && instr.var_name == "PRINT") {
        if (instr.atom_value) { 
            Expr print_instr = instr;
            if (instr.atom_value->type == Atom::STRING && instr.atom_value->string_value.empty()) {
                print_instr.atom_value = std::make_unique<Atom>("Hello world from " + processName + "!", Atom::STRING);
            }
            evaluator->handle_print(*print_instr.atom_value, processName);
        } else if (instr.lhs && instr.rhs) { 
            std::string lhs_str = evaluator->print_atom_to_string(*instr.lhs);
            std::string rhs_str = evaluator->print_atom_to_string(*instr.rhs);
            Atom temp_atom(lhs_str + rhs_str, Atom::STRING);
            evaluator->handle_print(temp_atom, processName);
        } else {
            
            evaluator->evaluate(instr);
        }
        return true;
    }
    
    
    evaluator->evaluate(instr);
    return true;
  } catch (const std::exception& e) {
    return false;
  }
}

const std::vector<std::string>& PCB::getExecutionLogs() const {
  return evaluator->get_output_log();
}

void PCB::setSleepCycles(uint16_t cycles) {
  sleepCyclesRemaining = cycles;
}

bool PCB::isSleeping() const {
  return sleepCyclesRemaining > 0;
}

void PCB::decrementSleepCycles() {
  if (sleepCyclesRemaining > 0) {
    --sleepCyclesRemaining;
  }
}

}


// =====================================================================
// FILE: ./src/scheduler.cpp
// =====================================================================

#include "scheduler.hpp"

#include <algorithm>
#include <atomic>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <random>
#include <sstream>
#include <thread>

#include "config.hpp"
#include "cpu_worker.h"
#include "process_control_block.hpp"

namespace osemu {

Scheduler::Scheduler() : running_(false), batch_generating_(false), process_counter_(0) {}

Scheduler::~Scheduler() {
  if (batch_generating_.load()) {
    stop_batch_generation();
  }
  if (running_.load()) {
    stop();
  }
}

void Scheduler::dispatch(){
  while(running_.load()){
    // This helper function frees cpus with expired time quantum or finished tasks
    bool one_free = find_idle_cpu(); 
    // Generate one process
    if(batch_generating_.load() && ticks_ % batch_process_freq_ == 0) generate_process(); 

    // If a free cpu exists try to pop and assign process to the free cpu.
    find_free_cpu_and_assign();
    // Signal all cores to run; IMPORTANT; all cores must participate even when idle
    // This function also blocks until all cores have participated 
    signal_execute(); 

    // Page faults are now handled individually by CpuWorkers during execution

    ticks_++;
  }
}

void Scheduler::global_clock() {
  while (running_.load()) {
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
    if (!running_.load()) break;

    {
      std::lock_guard<std::mutex> lock(clock_mutex_);
      ticks_++;
    }
    clock_cv_.notify_all();

    if (running_.load() && memory_manager_ &&
        (ticks_.load() % quantum_cycles_) == 0 && ticks_.load() > 0) {
      quantum_report_counter_++;
    }
  }
}

void Scheduler::check_config_scheduler_for_discrepancies(const Config& config) {
  std::cout << "debug: max_overall_mem " << config.max_overall_mem << std::endl;
  std::cout << "debug: maxOverallMem " << maxOverallMemory << std::endl;

  std::cout << "debug: mem_per_frame (config)" << config.mem_per_frame
            << std::endl;
  std::cout << "debug: memPerFrame (scheduler)" << memPerFrame << std::endl;

  std::cout << "debug: mem_per_proc_ (scheduler) " << mem_per_proc_
            << std::endl;
  std::cout << "debug: mem_per_proc_ (config) " << config.min_mem_per_proc
            << std::endl;

  std::cout << "debug: minMemPerProc - (scheduler) " << minMemPerProc
            << std::endl;
  std::cout << "debug: min_mem_per_proc - (config) " << config.min_mem_per_proc
            << std::endl;

  std::cout << "debug: maxMemPerProc - scheduler " << maxMemPerProc
            << std::endl;
  std::cout << "debug: max_mem_per_proc - config " << config.max_mem_per_proc
            << std::endl;
}
void Scheduler::start(const Config& config) {
  running_ = true;
  delay_per_exec_ = config.delayCyclesPerInstruction;
  quantum_cycles_ = config.quantumCycles;
  algorithm_ = config.scheduler;
  core_count_ = config.cpuCount;
  maxOverallMemory = config.max_overall_mem;
  memPerFrame = config.mem_per_frame;
  minMemPerProc = config.min_mem_per_proc;
  maxMemPerProc = config.max_mem_per_proc;
  minInstructions = config.minInstructions;
  maxInstructions = config.maxInstructions;

  memory_manager_ = std::make_unique<MemoryManager>(config.max_overall_mem, config.mem_per_frame);
  mem_per_proc_ = config.min_mem_per_proc;

  // Create CpuWorkers with vmstat integration
  for (uint32_t i = 0; i < config.cpuCount; ++i) {
    cpu_workers_.push_back(std::make_unique<CpuWorker>(i, *this));
    cpu_workers_.back()->Start();
  }

  std::cout << "Scheduler started with " << core_count_ << " cores."
            << std::endl;

  // debuggg
  // check_config_scheduler_for_discrepancies(config);

  dispatch_thread_ = std::thread(&Scheduler::dispatch, this);
}

void Scheduler::stop() {
  running_ = false;
  ready_queue_.shutdown();

  clock_cv_.notify_all();

  if(dispatch_thread_.joinable()){
    dispatch_thread_.join();
  }

  // Stop CpuWorkers
  for (auto& worker : cpu_workers_) {
      worker->Stop();
      worker->Join();
  }
  cpu_workers_.clear();
  
  if(global_clock_thread_.joinable()){
    global_clock_thread_.join();
  }

  memory_manager_.reset();

  std::cout << "Scheduler stopped." << std::endl;
  std::cout << "Number of cycles from this run: " << ticks_.load() << std::endl;
}

void Scheduler::submit_process(std::shared_ptr<PCB> pcb) {
  // Initialize page table for this process if memory manager is available
  if (memory_manager_) {
    // Calculate number of pages needed for process memory
    size_t process_memory_size = pcb->heap_memory.size();
    uint32_t num_pages = (process_memory_size + memPerFrame - 1) / memPerFrame; // Round up
    memory_manager_->initialize_page_table(pcb->processID, num_pages);
  }
  
  {
    std::lock_guard<std::mutex> lock(map_mutex_);
    all_processes_map_[pcb->processName] = pcb;
  }
  ready_queue_.push(std::move(pcb));
}

void Scheduler::print_status() const {
  double cpu_utilization;
  size_t total_cores = core_count_;
  size_t cores_used = 0;
  for (const auto& worker : cpu_workers_) {
    if (!worker->IsIdle()) {
      ++cores_used;
    }
  }
  calculate_cpu_utilization(total_cores, cores_used, cpu_utilization);

  std::cout << "CPU utilization: " << static_cast<int>(cpu_utilization) << "%\n";
  std::cout << "Cores used: " << cores_used << "\n";
  std::cout << "Cores available: " << (core_count_ - cores_used) << "\n\n";
  memory_manager_->generate_memory_report(std::cout);
  std::cout
      << "----------------------------------------------------------------\n";
  std::cout << "Running processes:\n";
  {
    std::lock_guard<std::mutex> lock(running_mutex_);
    for (const auto& pcb : running_processes_) {
      std::cout << pcb->status() << std::endl;
    }
  }

  std::cout << "\nFinished processes:\n";
  {
    std::lock_guard<std::mutex> lock(finished_mutex_);
    for (const auto& pcb : finished_processes_) {
      std::cout << pcb->status() << std::endl;
    }
  }
  std::cout
      << "----------------------------------------------------------------\n";
}

std::shared_ptr<PCB> Scheduler::find_process_by_name(const std::string& processName) const{
  std::lock_guard<std::mutex> lock(map_mutex_);
  
  auto it = all_processes_map_.find(processName);
  
  if (it != all_processes_map_.end()) {
    return it->second;
  }

  return nullptr;
}

void Scheduler::move_to_running(std::shared_ptr<PCB> pcb) {
  std::lock_guard<std::mutex> lock(running_mutex_);
  running_processes_.push_back(std::move(pcb));
}

void Scheduler::move_to_finished(std::shared_ptr<PCB> pcb) {
  {
    std::lock_guard<std::mutex> lock(running_mutex_);
    std::lock_guard<std::mutex> lock2(finished_mutex_);
    std::erase_if(running_processes_,
                  [&](const auto& p) { return p.get() == pcb.get(); });
    finished_processes_.push_back(std::move(pcb));
  }
}

void Scheduler::move_to_ready(std::shared_ptr<PCB> pcb) {
  {
    std::lock_guard<std::mutex> lock(running_mutex_);
    std::erase_if(running_processes_,
                  [&](const auto& p) { return p.get() == pcb.get(); });
  }

  ready_queue_.push(std::move(pcb));
}

void Scheduler::signal_execute(){
  workers_completed_step_count_.store(0); // Reset barrier counter
  
  {
    std::unique_lock<std::mutex> lock(barrier_mutex_); // Acquire barrier mutex
    bool expected = tick_ready_.load();
    bool desired;
    do {
      desired = !expected;
    } while(!tick_ready_.compare_exchange_weak(expected, desired));
  }
  dispatch_go_cv_.notify_all(); // Signal all CPUWorker threads to process their tick

  std::unique_lock<std::mutex> lock(barrier_mutex_); // Acquire barrier mutex

  workers_done_cv_.wait(lock, [&]{
    bool done = workers_completed_step_count_.load() >= cpu_workers_.size();
    bool shutting_down = !running_.load();
    return done || shutting_down;
  });
  
  // Barrier passed. All workers have processed their tick and updated their flags.
}

bool Scheduler::find_idle_cpu(){
  // Count active cores and check for idle workers
  bool has_idle = false;
  active_cores_ = 0;

  for(auto const& cpu: cpu_workers_){
    if(cpu->IsIdle()){
      has_idle = true;
    } else {
      active_cores_++;
    }
  }
  return has_idle;
}

void Scheduler::find_free_cpu_and_assign(){
  for(auto const& cpu: cpu_workers_){
    if(cpu->IsIdle()){
      std::optional<std::shared_ptr<PCB>> try_process = ready_queue_.try_pop(); 
      if(try_process.has_value()){
        std::shared_ptr<PCB> process = try_process.value();
        process->assignedCore = cpu->GetCoreId();
        cpu->AssignTask(process, quantum_cycles_);
        move_to_running(process);
      }
    }
  }
}

void Scheduler::generate_process() {
    std::string process_name;
    
    // Generate a unique process name using a mutex for shared counter
    { 
      std::lock_guard<std::mutex> lock(process_counter_mutex_);

      do {
        ++process_counter_;
        std::stringstream ss;
        ss << "p" << std::setw(2) << std::setfill('0') << process_counter_;
        process_name = ss.str();
      } while (find_process_by_name(process_name) != nullptr); // Ensure name is unique
    } 

    // Generate a random memory size for the process
    std::random_device rd;                         
    std::mt19937 gen(rd());                        
    // Use member variables for min/max memory per process (from Config)
    std::uniform_int_distribution<> dist(minMemPerProc, maxMemPerProc); 
    size_t memory_size = dist(gen);
   
    // Generate random instructions using captured config values
    auto instructions = instruction_generator_.generateRandomProgram(
      minInstructions, // Use the stored config values
      maxInstructions,
      process_name, 
      minMemPerProc, // These are for instruction generation context
      maxMemPerProc  // (match your existing usage in instruction_generator)
    );
   
    // Check if the process can fit in the allocated memory size
    if (instructions.size() + 64 > memory_size) {
      std::cerr << "Error: Process " << process_name
                << " has too many instructions for the allocated memory size."
                << std::endl;  
    } else {
      auto pcb = std::make_shared<PCB>(process_name, instructions, memory_size, memory_manager_.get());
      submit_process(pcb); // Submit the newly created process to the ready queue
    }
}

void Scheduler::start_batch_generation() {
  if (batch_generating_.load()) {
    std::cout << "Batch process generation is already running." << std::endl;
    return;
  }
  
  // Capture the relevant configuration parameters as member variables
  batch_generating_ = true; // Enable batch generation
  std::cout << "Started batch process generation." << std::endl;
}

void Scheduler::stop_batch_generation() {
  if (!batch_generating_.exchange(false)) { // Atomically set to false and check if it was already false
    return; // Batch generation was not running
  }

  // No batch_generator_thread_ to join or reset.

  // Report the total count of processes generated
  uint32_t count = 0;
  { // Lock to safely read the final process_counter_
    std::lock_guard<std::mutex> lock(process_counter_mutex_);
    count = process_counter_;
  }
  std::cout << count << " processes generated" << std::endl;
}

void Scheduler::calculate_cpu_utilization(size_t& total_cores,
                                          size_t& cores_used,
                                          double& cpu_utilization) const {

  cpu_utilization =
      total_cores > 0 ? (static_cast<double>(cores_used) / total_cores) * 100.0
                      : 0.0;
}

void Scheduler::generate_report(const std::string& filename) const {
  std::ofstream report_file(filename);
  
  if (!report_file.is_open()) {
    return;
  }

  double cpu_utilization;
  size_t total_cores = core_count_;
  size_t cores_used = 0;
  for (const auto& worker : cpu_workers_) {
    if (!worker->IsIdle()) {
      ++cores_used;
    }
  }

  calculate_cpu_utilization(total_cores, cores_used, cpu_utilization);

  report_file << "CPU utilization: " << static_cast<int>(cpu_utilization) << "%\n";
  report_file << "Cores used: " << cores_used << "\n";
  report_file << "Cores available: " << (core_count_ - cores_used) << "\n\n";

  report_file << "Running processes:\n";
  {
    std::lock_guard<std::mutex> lock(running_mutex_);
    for (const auto& pcb : running_processes_) {
      report_file << pcb->status() << "\n";
    }
  }
  
  report_file << "\nFinished processes:\n";
  {
    std::lock_guard<std::mutex> lock(finished_mutex_);
    for (const auto& pcb : finished_processes_) {
      report_file << pcb->status() << "\n";
    }
  }
  
  report_file.close();
  std::cout << "Report generated at " << filename << "!" << std::endl;
}

void Scheduler::print_process_smi() const {
  std::cout << "     _-----_\n";
  std::cout << "    |       |\n";
  std::cout << "    |--(o)--|\n";
  std::cout << "   `---------´\n";
  std::cout << "    ( CSOPESY )\n";
  std::cout << "     `-------´\n";
  std::cout << "      ___\n";
  std::cout << "     /   \\\n";
  std::cout << "|--------------------------------------------------|\n";
  std::cout << "| PROCESS-SMI V01.00 Driver Version: 01.00         |\n";
  std::cout << "|--------------------------------------------------|\n";
  
  // Calculate CPU utilization
  double cpu_utilization;
  size_t total_cores = core_count_;
  size_t cores_used = active_cores_;
  calculate_cpu_utilization(total_cores, cores_used, cpu_utilization);
  
  std::cout << "CPU-Util: " << static_cast<int>(cpu_utilization) << "%\n";
  
  if (memory_manager_) {
    uint32_t total_mem = memory_manager_->get_total_memory();
    uint32_t used_mem = memory_manager_->get_used_memory();
    
    std::cout << "Memory Usage: " << used_mem << " / " << total_mem << "\n";
    if (total_mem > 0) {
      std::cout << "Memory Util: " << static_cast<int>((double)used_mem / total_mem * 100) << "%\n";
    } else {
      std::cout << "Memory Util: 0%\n";
    }
  } else {
    std::cout << "Memory Usage: 0 / 0\n";
    std::cout << "Memory Util: 0%\n";
  }
  
  std::cout << "|--------------------------------------------------|\n";
  std::cout << "Running processes and memory usage:\n";
  std::cout << "|--------------------------------------------------|\n";
  
  {
    std::lock_guard<std::mutex> lock(running_mutex_);
    for (const auto& pcb : running_processes_) {
      // For simplicity, assuming each process uses mem_per_proc_ memory
      std::cout << pcb->processName << " " << pcb->heap_memory.size() << " bytes\n";
    }
  }
  
  std::cout << "|--------------------------------------------------|" << std::endl;
}

void Scheduler::print_vmstat() const {
  if (!memory_manager_) {
    std::cout << "Memory manager not available.\n";
    return;
  }
  
  uint32_t total_memory = memory_manager_->get_total_memory();
  uint32_t used_memory = memory_manager_->get_used_memory();
  uint32_t free_memory = memory_manager_->get_free_memory();
  
  size_t idle_ticks = idle_cpu_ticks_.load();
  size_t active_ticks = active_cpu_ticks_.load();
  size_t total_ticks = idle_ticks + active_ticks;
  
  std::cout << "Total memory: " << total_memory << " bytes\n";
  std::cout << "Used memory: " << used_memory << " bytes\n";
  std::cout << "Free memory: " << free_memory << " bytes\n";
  std::cout << "Idle cpu ticks: " << idle_ticks << "\n";
  std::cout << "Active cpu ticks: " << active_ticks << "\n";
  std::cout << "Total cpu ticks: " << total_ticks << "\n";
  std::cout << "Num paged in: " << memory_manager_->get_pages_paged_in() << "\n";
  std::cout << "Num paged out: " << memory_manager_->get_pages_paged_out() << std::endl;
}

}


// =====================================================================
// FILE: ./src/screen.cpp
// =====================================================================


#include "screen.hpp"

#include <atomic>  
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <memory>
#include <string>
#include <thread>  
#include <vector>

#include "console.hpp"  
#include "instruction_generator.hpp"
#include "process_control_block.hpp"
#include "instruction_parser.hpp"
#include "scheduler.hpp"

namespace osemu {
namespace {





std::shared_ptr<PCB> find_process(const std::string& process_name,
                                  Scheduler& scheduler) {
  if (scheduler.find_process_by_name(process_name) != nullptr) {
    return scheduler.find_process_by_name(process_name);
  }

  return nullptr;
}


void view_process_screen(const std::string& process_name, Scheduler& scheduler) {
  // scheduler gets the process
  try {
    std::shared_ptr<PCB> pcb = find_process(process_name, scheduler);

    if (!pcb) {
      throw std::runtime_error("Process " + process_name + " not found.");
    }
    std::cout << "\x1b[2J\x1b[H";


    std::string input_line;
    while (true) {
      std::cout << "Process name: " << process_name << std::endl;
      std::cout << "ID: "  << pcb->processID<< std::endl;
      std::cout << "Logs:" << std::endl;

      const auto& logs = pcb->getExecutionLogs();
      if (logs.empty()) {
        std::cout << "(No logs yet)" << std::endl;
      } else {
        for (const auto& log : logs) {
          std::cout << log << std::endl;
        }
      }

      std::cout << std::endl;
      std::cout << "Current instruction line: "<< pcb->currentInstruction << std::endl;
      std::cout << "Lines of code: " << pcb-> totalInstructions << std::endl;
      std::cout << std::endl;

      std::cout << "root:\\> ";
      if (!std::getline(std::cin, input_line)) {
        break;
      }

      if (input_line == "exit") {
        break;
      } else if (input_line == "process-smi") {
        scheduler.print_process_smi();
        std::cout << "\x1b[2J\x1b[H";
        continue;
      } else {
        std::cout << "Unknown command: " << input_line << std::endl;
        std::cout << "Available commands: process-smi, exit" << std::endl;
      }
    }


    std::cout << "\x1b[2J\x1b[H";
    console_prompt();
  }
  catch (const std::exception& e) {
    std::cout << e.what() << std::endl;

  }

}





bool create_process(const std::string& process_name, Scheduler& scheduler, Config& config, size_t memory_size = 512) {
  //check for existing processname
  if (scheduler.find_process_by_name(process_name) != nullptr) {
    std::cerr << "Error: Process '" << process_name << "' already exists. Please choose a unique name." << std::endl;
    return false; // Abort the creation
  }

  InstructionGenerator generator;

  auto instructions = generator.generateRandomProgram(config.minInstructions, config.maxInstructions, process_name, config.min_mem_per_proc, config.max_mem_per_proc);
  auto pcb = std::make_shared<PCB>(process_name, instructions, memory_size);
  
  std::cout << "Created process '" << process_name << "' with " 
            << instructions.size() << " instructions and memory size of "
            << memory_size << " bytes." << std::endl;
  
  scheduler.submit_process(pcb);
  return true;
}


void create_process_from_file(const std::string& filename, const std::string& process_name, Scheduler& scheduler) {
  std::ifstream file(filename);
  if (!file) {
    std::cerr << "Error: Could not open file " << filename << std::endl;
    return;
  }
  
  std::stringstream buffer;
  buffer << file.rdbuf();
  std::string input = buffer.str();
  
  std::vector<Expr> program;
  ParseResult result = InstructionParser::parse_program(input, program);
  
  if (!result.success) {
    std::cerr << "Parse error: " << result.error_msg << std::endl;
    std::cerr << "Remaining input: " << result.remaining << std::endl;
    return;
  }
  
  auto pcb = std::make_shared<PCB>(process_name, program);
  
  std::cout << "Created process '" << process_name << "' from file '" << filename 
            << "' with " << program.size() << " instructions." << std::endl;
  
  scheduler.submit_process(pcb);
}


std::string unescapeQuotes(const std::string& str) {
    std::string result;
    bool inEscape = false;
    
    for (size_t i = 0; i < str.length(); ++i) {
        if (str[i] == '\\' && i + 1 < str.length() && str[i + 1] == '"') {
            // Skip the escape sequence for a quote
            result += '"';
            ++i; // Skip the next character (the quote)
        } else {
            result += str[i];
        }
    }

    return result;
}

std::string transformInstructions(const std::string& input) {
    std::string result;
    std::string tempInput = input;

    // Remove the starting and ending double quotes
    if (!tempInput.empty() && tempInput.front() == '"' && tempInput.back() == '"') {
        tempInput = tempInput.substr(1, tempInput.size() - 2);
    }

    // Unescape all double quotes
    tempInput = unescapeQuotes(tempInput);

    // Split the input by semicolons
    std::istringstream stream(tempInput);
    std::string line;

    while (std::getline(stream, line, ';')) {
        // Trim leading/trailing spaces
        size_t start = line.find_first_not_of(" \t");
        size_t end = line.find_last_not_of(" \t");
        if (start == std::string::npos) continue; // skip empty/whitespace lines
        line = line.substr(start, end - start + 1);

        // Pass through lines that are already in the form FUNCTION(args)
        if (line.find('(') != std::string::npos && line.back() == ')') {
            result += line + "\n";
            continue;
        }

        // Parse and transform other instructions
        std::istringstream instrStream(line);
        std::string instruction;
        instrStream >> instruction;

        result += instruction + "(";

        std::string arg;
        bool first = true;
        while (instrStream >> arg) {
            if (!first) result += ", ";
            result += arg;
            first = false;
        }

        result += ")\n";
    }

    return result;
}



void create_process_from_string(const std::string& process_name, size_t memory, const std::string& instructions, Scheduler& scheduler){
  //remove starting and ending "
  //unescape all \" 
  std::string input = transformInstructions(instructions);
  std::vector<Expr> program;
  ParseResult result = InstructionParser::parse_program(input, program);

  if (!result.success) {
    std::cerr << "Parse error: " << result.error_msg << std::endl;
    std::cerr << "Remaining input: " << result.remaining << std::endl;
    return;
  }
  
  auto pcb = std::make_shared<PCB>(process_name, program, memory);
  
  std::cout << "Created process '" << process_name << " with " << memory << "bytes of memory." << std::endl;
  
  scheduler.submit_process(pcb);

}

enum class ScreenCommand { Start, Resume, List, File, Custom, Unknown };

void display_usage() {
  std::cout
      << "Usage:\n"
      << "  screen -s <name>     Start a new process with the given name.\n"
      << "  screen -r <name>     View the real-time log of a running process.\n"
      << "  screen -ls           List all active processes.\n"
      << "  screen -f <file> <name>  Load process from .opesy file.\n"
      << "  screen -c <name> <process_memory_size> \"<instructions>\" Make a custom process with instructions\n" ;
}

ScreenCommand parse_command(const std::string& cmd) {
  if (cmd == "-s") return ScreenCommand::Start;
  if (cmd == "-r") return ScreenCommand::Resume;
  if (cmd == "-ls") return ScreenCommand::List;
  if (cmd == "-f") return ScreenCommand::File;
  if (cmd == "-c") return ScreenCommand::Custom;
  return ScreenCommand::Unknown;
}

}  


void screen(std::vector<std::string>& args, Scheduler& scheduler, Config& config) {
  if (args.empty()) {
    display_usage();
    return;
  }

  const ScreenCommand cmd = parse_command(args[0]);

  switch (cmd) {
    case ScreenCommand::Start: {
      if(args.size() == 3) {
        try {
          size_t mem_siz  = static_cast<size_t>(std::stoull(args[2]));
          bool created_success = create_process(args[1], scheduler, config, mem_siz);
          if (created_success) {
            view_process_screen(args[1],scheduler);
          }
          break;
        } catch (const std::invalid_argument& e) {
            std::cout << "Invalid argument: " << e.what() << std::endl;
        } catch (const std::out_of_range& e) {
            std::cout << "Out of range: " << e.what() << std::endl;
        }
      } else if (args.size() == 2) {
        bool created_success = create_process(args[1], scheduler, config);
        if (created_success) {
          view_process_screen(args[1],scheduler);
        }
        break;
      } else {
        display_usage();
        return;
      }
    }
    case ScreenCommand::Resume:
      if (args.size() != 2) {
        display_usage();
        return;
      }
      view_process_screen(args[1], scheduler);
      break;

    case ScreenCommand::List:
      scheduler.print_status();
      break;

    case ScreenCommand::File:
      if (args.size() != 3) {
        display_usage();
        return;
      }
      create_process_from_file(args[1], args[2], scheduler);
      break;

    case ScreenCommand::Custom:
      size_t num;

      //error handling
      if(args.size() != 4){
        display_usage();
        return;
      } 

      //more error handling
      try {
        num = std::stoul(args[2]);
      } catch(...) {
        std::cout << "Please input a valid number for process_memory_size" << std::endl;
      }

      create_process_from_string(args[1], num, args[3], scheduler);

    break;
    case ScreenCommand::Unknown:
    default:
      std::cout << "Unknown screen command: " << args[0] << "\n";
      display_usage();
      break;
  }
}

}

